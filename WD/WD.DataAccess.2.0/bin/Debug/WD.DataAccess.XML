<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WD.DataAccess</name>
    </assembly>
    <members>
        <member name="T:WD.DataAccess.Abstract.ICommands">
            <summary>
            Commands is main abstract class  which helps to communicate with databases (SQL,Oracle,Db2 and
            TeraData)
            ICommands have few build in functions which are listed as below: ExecuteDataReader
            ExecuteDataSet ExecuteDataTable GetList GetEntity Insert Update Delete ExecuteNonQuery
            ExecuteRecordSet ExecuteScalar.
            </summary>
            <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IMTech">
            <summary>
            IMTech  is an abstract class for MITECH Solutions for
            ExecuteNonQuery,ExecuteScalar,
            ExecuteDataSet,ExecuteDataTable,
            ExecuteDataReader,ExecuteEntity,ExecuteRecordSet
            </summary>
            <seealso cref="T:WD.DataAccess.Abstract.IExecuteScalar"/>
            <remarks>Shahid K, 7/24/2017.</remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IExecuteScalar">
            <summary>   
            IExecuteScalar is an abstract class for executes calar methods.
             </summary>
            <remarks>   Shahid K, 7/24/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IExecuteRecordSet">
            <summary>  
            IExecuteRecordSet is an abstract class for  ADODB.Recordset methods.
            </summary>
            <remarks>   Shahid K, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IExecuteNonQuery">
             <summary>   IExecuteNonQuery is an abstract class for ExecuteNonQuery methods. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IExecuteDataTable">
             <summary>   IExecuteDataTable is an abstract class  for ExecuteDataTable methods. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IExecuteDataSet">
             <summary>   IExecuteDataSet is an abstract class for ExecuteDataSet methods. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Abstract.IExecuteDataReader">
            <summary>
            IExecuteDataReader is an abstract class for ExecuteDataReader methods
            </summary>
        </member>
        <member name="T:WD.DataAccess.Abstract.IDatabase">
            <summary>
            IDatabase is an abstract class which helps in connections,transactions and commands
            </summary>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateConnection">
            <summary>
            Creates  instance of Connection.
            </summary>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
            IDbConnection con=command.CreateConnection();
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
            
            <returns>The new connection.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateOpenConnection">
            <summary>
            Creates instance of Open Connection.
            </summary>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
             IDbConnection con=command.CreateOpenConnection();
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
            <returns>The new open connection.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateOpenConnection(System.Data.IDbConnection)">
            <summary>
            Creates  instance of Open Connection for connection passed.
            </summary>
            <param name="con">Connection object.</param>
            <returns>The new open connection.</returns>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
             using(IDbConnection con=command.CreateConnection()){
             ///it will open given connection
             commad.CreateOpenConnect(con);
             
             }
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateConnection(System.String)">
            <summary>
            Creates  instance of  Connection for connection string passed.
            </summary>
            <param name="connectionString">.</param>
            <returns>The new connection.</returns>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
             using(IDbConnection con=command.CreateConnection("DataSource=XXX;UserId=XXX;Password=XXX")){
             
             }
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateOpenConnection(System.String)">
            <summary>
            Creates  instance of  Connection for connection string passed.
            </summary>
            <param name="connectionString">.</param>
            <returns>The new open connection.</returns>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
             using(IDbConnection con=command.CreateOpenConnection("DataSource=XXX;UserId=XXX;Password=XXX")){
             
             }
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CloseConnection">
            <summary>
            Closes current connection.
            </summary>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
            command.CloseConnection();
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateParameter(System.String,System.Object)">
            <summary>
            Create Instance of Parameter.
            </summary>
            <param name="parameterName">Parameter Name.</param>
            <param name="parameterValue">Parameter Value.</param>
            <returns>DBParameter Object.</returns>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
            DBParameter aParam=command.CreateParameter("FirstName","XXX");
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateParameter">
            <summary>
            Create Instance of Parameter.
            </summary>
            <returns>DBParameter Object.</returns>
            <example>
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
            DBParameter aParam=command.CreateParameter();
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.GetParameterValue(System.String,System.Data.IDbCommand)">
            <summary>
            Create Instance of Parameter.
            </summary>
            <param name="parameterName">Parameter Name.</param>
            <param name="command">Command Object having collection of parameter.</param>
            <returns>Parameter Value Object.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.GetParameterValue(System.Int32,System.Data.IDbCommand)">
            <summary>
            Create Instance of Parameter.
            </summary>
            <param name="index">Parameter Index.</param>
            <param name="command">Command Object having collection of parameter.</param>
            <returns>Parameter Value Object.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.BeginTransaction">
            <summary>
            Creates Transaction instance for default connection.
            </summary>
            <returns>Transaction Object.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.BeginTransaction(System.Data.IDbConnection)">
            <summary>
            Creates Transaction instance for passed connection.
            </summary>
            <param name="connection">Active Connection Object.</param>
            <returns>Transaction Object.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CommitTransaction(System.Data.IDbTransaction)">
            <summary>
            Commits Transaction object for passed transaction.
            </summary>
            <param name="transaction">Active Transaction object.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.RollbackTransaction(System.Data.IDbTransaction)">
            <summary>
            Rolls Backs passed Active Transaction object.
            </summary>
            <param name="transaction">Active Transaction object.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.DisposeTransaction(System.Data.IDbTransaction)">
            <summary>
            Disposed passed Active Transaction object.
            </summary>
            <param name="transaction">Active Transaction object.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateCommand">
            <summary>
            Creates Command Instance For active DBProvider.
            </summary>
            <returns>Active Command object.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateCommand(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates Command Instance For active DBProvider for CommandText, CommandType and Optional
             parameter.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional parameter. </param>
            
             <returns>   Active Command object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateCommand(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
            <summary>
            Creates Command Instance For active DBProvider for CommandText, CommandType, Connection and
            Optional parameter.
            </summary>
            <param name="commandText">Open Sql Statement or Procedure Name.</param>
            <param name="commandType">CommandType for Text or StoredProcedure (1 or 4)</param>
            <param name="connection">Active Connection Object.</param>
            <param name="aParams">(Optional) Collection of Optional parameter.</param>
            <returns>Active Command object.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.CreateCommand(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
            <summary>
            Creates Command Instance For active DBProvider for CommandText, CommandType, Transaction and
            Optional parameter.
            </summary>
            <param name="commandText">Open Sql Statement or Procedure Name.</param>
            <param name="commandType">CommandType for Text or StoredProcedure (1 or 4)</param>
            <param name="transaction">Active Transaction Object.</param>
            <param name="aParams">(Optional) Collection of Optional parameter.</param>
            <returns>Active Command object.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IDatabase.DisposeCommand(System.Data.IDbCommand)">
            <summary>
            Disposed passed Active Command object.
            </summary>
            <param name="command">Active Command object.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="P:WD.DataAccess.Abstract.IDatabase.Connection">
            <summary>
            Protected Connection Property.
            </summary>
            <value>Returns initialized Connection.</value>
        </member>
        <member name="P:WD.DataAccess.Abstract.IDatabase.DBProvider">
            <summary>
            Protected DBProvider Property.
            </summary>
            <value>The database provider.</value>
        </member>
        <member name="P:WD.DataAccess.Abstract.IDatabase.BXConnection">
            <summary>
            Gets the bx connection.
            </summary>
            <value>The bx connection.</value>
        </member>
        <member name="P:WD.DataAccess.Abstract.IDatabase.TXConnection">
            <summary>
            Gets the tx connection.
            </summary>
            <value>The tx connection.</value>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Creates instance of DataReader for commandText and optional Parameters. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName")){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName
               where FirstName=@FirstName",aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active DataReader object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataReader for commandText, connection and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName",con)){
                 //write your code
                  
               }
               }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName
               where FirstName=@FirstName",con,aParams);{
                 //write your code
                  
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataReader for commandText, transaction and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName",trans))
                     {
                      //write your code
                  
                     }
               
                     trans.Commit();
                  }
                catch
                 {
                       trans.Rollback();
                 }
               }
              }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
                 WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                   aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                 aParams[0].ParameterName="FirstName";
                 aParams[0].ParameterValue="first name";
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName where FirstName=@FirstName",trans,aParams);
                      {
                     //write your code
            
                      }
                    trans.Commit();
                }
               catch{ 
                     trans.Rollback();
                     }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataReader for commandText, commandType and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName",CommandType.Text)){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataReader for commandText,commandType,active connection and optional
             Parameters.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName",CommandType.Text,con)){
                 //write your code
                  
               }
               }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,con,aParams);{
                 //write your code
                  
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataReader for commandText,commandType, active transaction and optional
             Parameters.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName",CommandType.Text,trans))
                     {
                      //write your code
                  
                     }
               
                     trans.Commit();
                  }
                catch
                 {
                       trans.Rollback();
                 }
               }
              }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
                 WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                   aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                 aParams[0].ParameterName="FirstName";
                 aParams[0].ParameterValue="first name";
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(IDataReader reader=dbContext.ICommands.ExecuteDataReader("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,trans,aParams);
                      {
                     //write your code
            
                      }
                    trans.Commit();
                }
               catch{ 
                     trans.Rollback();
                     }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataReader.ExecuteDataReader(System.String,System.Data.CommandType,System.Data.IDbConnection,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataReader for commandText,commandType, active connection, active
             transaction and optional Parameters.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText  and optional Collection of
             Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              DataSet ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName where FirstName=@FirstName",aParams);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText ,active connection and optional
             Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
                DataSet ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName",dbConnection);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName where FirstName=@FirstName",dbConnection,aParams);
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText ,active transaction and optional
             Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=dbConnection.BeginTransaction())
               {
               try{
                 DataSet ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName",trans);
               //or
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="FirstName";
                aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName where FirstName=@FirstName",trans,aParams);
                trans.Commit();
                }catch{
                trans.Rollback();
                }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText ,commandType and optional
             Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              DataSet ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText ,commandType,  active connection
             and optional Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
                DataSet ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName",CommandTyp.Text,dbConnection);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,dbConnection,aParams);
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText ,commandType,  active transaction
             and optional Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=dbConnection.BeginTransaction())
               {
               try{
                 DataSet ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName",CommandType.Text,trans);
               //or
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="FirstName";
                aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,trans,aParams);
                trans.Commit();
                }catch{
                trans.Rollback();
                }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(System.String,System.Data.CommandType,System.Data.IDbConnection,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataSet for collection of commandText ,commandType,active connection,
             active transaction and optional Collection of Parameters.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      Collection of Optional Parameters. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(WD.DataAccess.Helpers.SqlStatement[])">
             <summary>   Executes the data set operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               SqlStatement[] input=new SqlStatement[1];
               input.CommandText="Select columnNames from tableName";
               input.CommandType=CommandType.Text;
                DataSet ds=dbContext.ICommands.ExecuteDataSet(input);
               //or
               input=new SqlStatement[1];
               input.CommandText="Select columnNames from tableName";
               input.CommandType=CommandType.Text;
               input.Params=new WD.DataAccess.Parameters.DBParameter[1];
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                input.Params[0]=new WD.DataAccess.Parameters.DBParameter();
                input.Params[0].ParameterName="FirstName";
                input.Params[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(input);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">    Object of Entity. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbConnection)">
             <summary>
             Creates instance of DataSet for collection of Sql Statements ,collection of  commandType, and
             active connection.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
               SqlStatement[] input=new SqlStatement[1];
               input.CommandText="Select columnNames from tableName";
               input.CommandType=CommandType.Text;
                DataSet ds=dbContext.ICommands.ExecuteDataSet(input,dbConnection);
               //or
               input=new SqlStatement[1];
               input.CommandText="Select columnNames from tableName";
               input.CommandType=CommandType.Text;
               input.Params=new WD.DataAccess.Parameters.DBParameter[1];
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                input.Params[0]=new WD.DataAccess.Parameters.DBParameter();
                input.Params[0].ParameterName="FirstName";
                input.Params[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(input,dbConnection);
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">        Object of Entity. </param>
             <param name="connection">   Active Connection Object. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbTransaction)">
             <summary>
             Creates instance of DataSet for collection of Sql Statements ,collection of  commandType, and
             active transaction.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
                using(IDbTransaction trans=dbConnection.BeginTransaction())
               {
               try
               {
               SqlStatement[] input=new SqlStatement[1];
               input.CommandText="Select columnNames from tableName";
               input.CommandType=CommandType.Text;
                DataSet ds=dbContext.ICommands.ExecuteDataSet(input,trans);
               //or
               input=new SqlStatement[1];
               input.CommandText="Select columnNames from tableName";
               input.CommandType=CommandType.Text;
               input.Params=new WD.DataAccess.Parameters.DBParameter[1];
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                input.Params[0]=new WD.DataAccess.Parameters.DBParameter();
                input.Params[0].ParameterName="FirstName";
                input.Params[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(input,trans);
                trans.Commit();
                }
                catch{
                trans.Rollback();
                }
                }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">        Object of Entity. </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   Collection of Tables. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataSet.ExecuteDataSet(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbConnection,System.Data.IDbTransaction)">
            <summary>
            Creates instance of DataSet for collection of Sql Statements ,collection of  commandType,
            active connection and active transaction.
            </summary>
            <param name="input">Object of Entity.</param>
            <param name="connection">Active Connection Object.</param>
            <param name="transaction">Active Transaction Object.</param>
            <returns>Collection of Tables.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for commandText  and optional Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              DataTable dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName where FirstName=@FirstName",aParams);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for  commandText, active Connection  and optional Collection of
             Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
                DataTable dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName",dbConnection);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName where FirstName=@FirstName",dbConnection,aParams);
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for  commandText, active transaction  and optional Collection
             of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=dbConnection.BeginTransaction())
               {
             try
             {
                 DataTable dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName",trans);
               //or
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="FirstName";
                aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName where FirstName=@FirstName",trans,aParams);
                trans.Commit();
              }
              catch
              {
               trans.Rollback();
              }
              }
              }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for commandText,CommandType and optional Collection of
             Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              DataTable dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for commandText, CommandType, active Connection and optional
             Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
                DataTable dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName",CommandTyp.Text,dbConnection);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,dbConnection,aParams);
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for commandText, CommandType, active Transaction  and optional
             Collection of Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection dbConnection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=dbConnection.BeginTransaction())
               {
               try{
                 DataTable dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName",CommandType.Text,trans);
               //or
                WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="FirstName";
                aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,trans,aParams);
                trans.Commit();
                }catch{
                trans.Rollback();
                }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteDataTable.ExecuteDataTable(System.String,System.Data.CommandType,System.Data.IDbConnection,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Creates instance of DataTable for collection of commandText and optional Collection of
             Parameters.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      Collection of Optional Parameters. </param>
            
             <returns>   Collection of Records as Table. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Returns Rows Affected for CommandText and optional Parameter Collection. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
                rowsEffected=dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",aParams);
             }
             }
             </code>
            </example>
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",con);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
                rowsEffected=dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",con,aParams);
                }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=con.BeginTransaction())
               {
               try
               {
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",trans);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
                rowsEffected=dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",trans,aParams);
                trans.Commit();
                }
                catch{
                trans.Rollback();
                }
                }
                }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
                rowsEffected=dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",CommandType.Text,con);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
                rowsEffected=dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",CommandType.Text,con,aParams);
                }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(System.String,System.Data.CommandType,System.Data.IDbConnection,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=con.BeginTransaction())
               {
               try
               {
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",trans);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
                rowsEffected=dbContext.ICommands.ExecuteNonQuery("INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",CommandType.Text,trans,aParams);
                trans.Commit();
                }
                catch{
                trans.Rollback();
                }
                }
                }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      Collection of Optional Parameters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(WD.DataAccess.Helpers.SqlStatement[])" -->
        <!-- Badly formed XML comment ignored for member "M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbConnection)" -->
        <!-- Badly formed XML comment ignored for member "M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbTransaction)" -->
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.ExecuteNonQuery(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Executes the non query operation. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">        Collection of SQL Statements With CommandText,CommandType and
                                         Optional parameters. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkInsert(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select FirstName from employee");
               <!--Dictionary<string,string> cols=new Dictionary<string,string>();-->//
              <!-- cols.Add("FirstName","FirstName");-->//
              //int rowsEffected =dbContext.ICommands.BulkInsert(dt,"Employee",100,30,cols);//
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkInsert(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection)">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select FirstName from employee",con);
               <!--Dictionary<string,string> cols=new Dictionary<string,string>();-->//
               <!-- cols.Add("FirstName","FirstName");-->//
               //int rowsEffected =dbContext.ICommands.BulkInsert(dt,"Employee",100,30,cols,con);//
              }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
             <param name="connection">   Active Connection Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkInsert(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbTransaction)">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbConnection trans=con.BeginTransaction())
               {
               try{
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select FirstName from employee",trans);
               <!--Dictionary<string,string> cols=new Dictionary<string,string>();-->//
               <!-- cols.Add("FirstName","FirstName");-->//
              //int rowsEffected =dbContext.ICommands.BulkInsert(dt,"Employee",100,30,cols,trans);//
              trans.Commit();
              }
              catch{
              trans.Rollback();
              }
              
              }
              }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkInsert(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk insert. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkUpdate(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk Update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();      
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {  
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id,FirstName,LastName from employee",connection);        
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;();
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkUpdate(dt,"Employee",100,30,columnNames,primaryColumns);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             } 
             } 
             }  
             </code>
            </example> 
             <remarks>  3/23/2018 . </remarks>
            
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param>
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated . </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkUpdate(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection)">
             <summary>   Bulk Update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {         
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;()
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkUpdate(dt,"Employee",100,30,columnNames,primaryColumns,connection);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }       
             }  
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param>
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated . </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>
             <param name="connection"> Active Connection Object . </param>        
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkUpdate(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbTransaction)">
             <summary>   Bulk Update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();   
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {    
               using(IDbTransaction transaction=con.BeginTransaction())
               {          
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;()
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkUpdate(dt,"Employee",100,30,columnNames,primaryColumns,transaction);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }  
             }       
             }  
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param>
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated . </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>        
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkUpdate(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk Update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction transaction=con.BeginTransaction())
               {  
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;()
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkUpdate(dt,"Employee",100,30,columnNames,primaryColumns,connection,transaction);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }  
             } 
             }  
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param>
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated . </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>
             <param name="connection"> Active Connection Object . </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkDelete(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk Delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();    
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {  
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id from employee",connection);
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkDelete(dt,"Employee",100,30,primaryColumns);//       
               }
              catch
              {        
              }        
             }  
             } 
             }
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param> 
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkDelete(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection)">
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkDelete(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbTransaction)">
             <summary>   Bulk Delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();  
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction transaction=con.BeginTransaction())
               {         
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id from employee",connection);
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkDelete(dt,"Employee",100,30,primaryColumns,transaction);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }          
             } 
             }
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>         
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteNonQuery.BulkDelete(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk Delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction transaction=con.BeginTransaction())
               {  
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id from employee",connection);
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkDelete(dt,"Employee",100,30,primaryColumns,connection,transaction);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }  
             } 
             }  
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>
             <param name="connection"> Active Connection Object . </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Returns RecordSet for CommandText and optional Parameter Collection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName")){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName
               where FirstName=@FirstName",aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns RecordSet for CommandText, active connection and optional Parameter Collection.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName",con)){
                 //write your code
                  
               }
               }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName
               where FirstName=@FirstName",con,aParams);{
                 //write your code
                  
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns RecordSet for CommandText, active transaction and optional Parameter Collection.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName",trans))
                     {
                      //write your code
                  
                     }
               
                     trans.Commit();
                  }
                catch
                 {
                       trans.Rollback();
                 }
               }
              }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
                 WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                   aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                 aParams[0].ParameterName="FirstName";
                 aParams[0].ParameterValue="first name";
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName where FirstName=@FirstName",trans,aParams);
                      {
                     //write your code
            
                      }
                    trans.Commit();
                }
               catch{ 
                     trans.Rollback();
                     }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns RecordSet for CommandText, CommandType and optional Parameter Collection.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName",CommandType.Text)){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns RecordSet for CommandText, CommandType, active connection and optional Parameter
             Collection.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName",CommandType.Text,con)){
                 //write your code
                  
               }
               }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection()){
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,con,aParams);{
                 //write your code
                  
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns RecordSet for CommandText, CommandType, active transaction and optional Parameter
             Collection.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(ADODB.Recordset  recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName",CommandType.Text,trans))
                     {
                      //write your code
                  
                     }
               
                     trans.Commit();
                  }
                catch
                 {
                       trans.Rollback();
                 }
               }
              }
               //or
               using (IDbConnection con=dbContext.ICommands.CreateConnection())
               {
                 WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
                   aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                 aParams[0].ParameterName="FirstName";
                 aParams[0].ParameterValue="first name";
               using(IDbTransaction trans=connection.BeginTransaction())
               {
                 try
                 {
                     using(ADODB.Recordset  recordSet=dbContext.ICommands.ExecuteRecordSet("Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,trans,aParams);
                      {
                     //write your code
            
                      }
                    trans.Commit();
                }
               catch{ 
                     trans.Rollback();
                     }
               }
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteRecordSet.ExecuteRecordSet(System.String,System.Data.CommandType,System.Data.IDbConnection,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns RecordSet for CommandText, CommandType, active connection, active transaction and
             optional Parameter Collection.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      Collection of Optional Parameters. </param>
            
             <returns>   Active RecordSet Object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              string firstName=(string)dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=1");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue=1;
                firstName=dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=@F",aParams);
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection()){
              string firstName=(string)dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=1",con);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue=1;
                firstName=dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=@F",con,aParams);
                }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection()){
               using(IDbTransaction trans=con.BeginTransaction()){
               try{
              string firstName=(string)dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=1",trans);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue=1;
                firstName=dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=@F",trans,aParams);
                trans.Commit();
                }
                catch{
                trans.Rollback();
                }
                }
                }
             }
             }
             </code>
             </example>  
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              string firstName=(string)dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=1",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue=1;
                firstName=dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=@F",CommandType.Text,aParams);
             }
             }
             </code>
             </example>  
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,System.Data.CommandType,System.Data.IDbConnection,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection()){
              string firstName=(string)dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=1",CommandType.Text,con);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue=1;
                firstName=dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=@F",CommandType.Text,con,aParams);
                }
             }
             }
             </code>
             </example>  
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,System.Data.CommandType,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection()){
               using(IDbTransaction trans=con.BeginTransaction()){
               try{
              string firstName=(string)dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=1",CommandType.Text,trans);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue=1;
                firstName=dbContext.ICommands.ExecuteScalar("Select FirstName from employee where EmployeeId=@F",CommandType.Text,trans,aParams);
                trans.Commit();
                }
                catch{
                trans.Rollback();
                }
                }
                }
             }
             }
             </code>
             </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(System.String,System.Data.CommandType,System.Data.IDbConnection,System.Data.IDbTransaction,WD.DataAccess.Parameters.DBParameter[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
             <param name="aParams">      Collection of Optional Parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(WD.DataAccess.Helpers.SqlStatement[])">
             <summary>
             Returns Object Item as per the scalar Query for CommandText and optional Parameters.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">    Collection of SQL Statments With CommandText,CommandType and Optional
                                     parameters. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbConnection)">
             <summary>
             Returns Object Item as per the scalar Query forCommandText,Command Type, optional Parameters
             and Active Connection Object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">        Collection of SQL Statments With CommandText,CommandType and
                                         Optional parameters. </param>
             <param name="connection">   Active Connection Object. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbTransaction)">
             <summary>
             Returns Last Object Item from the collection of  Query for CommandText,Command Type, optional
             Parameters and Active transaction Object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">        Collection of SQL Statments With CommandText,CommandType and
                                         Optional parameters. </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IExecuteScalar.ExecuteScalar(WD.DataAccess.Helpers.SqlStatement[],System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>
             Returns Last Object Item from the collection of  Query for CommandText,Command Type, optional
             Parameters , Active Connection Object and Active transaction Object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="input">        Collection of SQL Statments With CommandText,CommandType and
                                         Optional parameters. </param>
             <param name="connection">   Active Connection Object. </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   object of any type. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.DetermineIndex(System.Int32@)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.GetTransaction(System.Boolean@,System.Boolean@,System.Int32)">
            <summary>   Gets a transaction. </summary>
            <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            <param name="isTransaction">        [in,out] True if this object is transaction. </param>
            <param name="isTransactionScope">   [in,out] True if this object is transaction scope. </param>
            <param name="transaction">          (Optional) </param>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Exception@,WD.DataAccess.Mitecs.Connections,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[],System.Boolean)">
            <summary>   Executes the non query operation. </summary>
            <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            <param name="ex">               [in,out] Details of the exception. </param>
            <param name="connection">       The connection. </param>
            <param name="commandText">      . </param>
            <param name="commandType">      CommandType for Text or StoredProcedure (1 or 4) </param>
            <param name="aParams">          . </param>
            <param name="isTransaction">    (Optional) True if this object is transaction. </param>
            <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkInsert(System.Exception@,WD.DataAccess.Mitecs.Connections,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>   Bulk insert. </summary>
            <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            <param name="ex">               [in,out] Details of the exception. </param>
            <param name="connection">       The connection. </param>
            <param name="dt">               . </param>
            <param name="tableName">        . </param>
            <param name="batchSize">        . </param>
            <param name="timeOut">          . </param>
            <param name="columnNames">      . </param>
            <param name="isTransaction">    (Optional) True if this object is transaction. </param>
            <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkUpdate(System.Exception@,WD.DataAccess.Mitecs.Connections,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>   Bulk Update. </summary>      
            <param name="ex">               [in,out] Details of the exception. </param>
            <param name="connection">       The connection. </param>
            <param name="dt">               . </param>
            <param name="tableName">        . </param>
            <param name="batchSize">        . </param>
            <param name="timeOut">          . </param>
            <param name="columnNames">      . </param>
            <param name="primaryColumns">      . </param>
            <param name="isTransaction">    (Optional) True if this object is transaction. </param>
            <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkDelete(System.Exception@,WD.DataAccess.Mitecs.Connections,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>   Bulk delete. </summary>
            <remarks>    . </remarks>
            <param name="ex">               [in,out] Details of the exception. </param>
            <param name="connection">       The connection. </param>
            <param name="dt">               . </param>
            <param name="tableName">        . </param>
            <param name="batchSize">        . </param>
            <param name="timeOut">          . </param>
            <param name="primaryColumns">      . </param>
            <param name="isTransaction">    (Optional) True if this object is transaction. </param>
            <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String)">
             <summary>   Returns Rows Affected for CommandText</summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')");
            
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="commandText"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Returns Rows Affected for CommandText and Parameter Collection. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
            
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
               int rowsEffected=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",aParams);
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String)">
             <summary>   Returns Rows Affected for CommandText</summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')");
            
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Returns Rows Affected for CommandText and Parameter Collection. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
            
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
               int rowsEffected=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",aParams);
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,System.Data.CommandType)">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",CommandType.Text);
               
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
               int rowsEffected=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,System.Data.CommandType)">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              int rowsEffected =dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES('XYX')",CommandType.Text);
               
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the non query operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
              
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="F";
               aParams[0].ParameterValue="XXX";
               int rowsEffected=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,"INSERT INTO EMPLOYEE(FIRSTNAME) VALUES(@F)",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[],System.Int32)">
             <summary>   Executes the non query operation. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <exception cref="T:System.Exception">    Thrown when an exception error condition occurs. </exception>
            
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
             <param name="transaction">  (Optional) </param>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             string theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES('12121')";
             
             
             //No Transaction while inserting record or set of records
             int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,null,WD.DataAccess.Enums.Transaction.None);
             or
             use Transaction while inserting record or set of records
              returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,null,WD.DataAccess.Enums.Transaction.Yes);
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,null,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,null,WD.DataAccess.Enums.Transaction.TSNT);
               
               //QUERY WITH PARAMETER
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(WD.Helpers.HelperUtility.Prefix(dbContext.ICommands.DbProvider)+'aColName')";
                WD.DataAccess.Parameters.DBParameter[] aParams= new WD.DataAccess.Parameters.DBParameter[1]
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="aColName";
                aParams[0].ParameterValue="abcd";
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,aParams,WD.DataAccess.Enums.Transaction.Yes);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[],System.Int32)">
             <summary>
              Executes the non query operation.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             
               //QUERY WITH PARAMETER
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(@aColName)";
                WD.DataAccess.Parameters.DBParameter[] aParams= new WD.DataAccess.Parameters.DBParameter[1]
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="aColName";
                aParams[0].ParameterValue="abcd";
               int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,aParams,WD.DataAccess.Enums.Transaction.Yes);
               
             //No Transaction while inserting record or set of records
                returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,aParams,WD.DataAccess.Enums.Transaction.None);
            
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,aParams,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,aParams,WD.DataAccess.Enums.Transaction.TSNT);
               
             
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks> 
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <param name="transaction"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[],System.Int32)">
             <summary>
              Executes the non query operation.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             
               //QUERY WITH PARAMETER
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(@aColName)";
                WD.DataAccess.Parameters.DBParameter[] aParams= new WD.DataAccess.Parameters.DBParameter[1]
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="aColName";
                aParams[0].ParameterValue="abcd";
               int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.Yes);
               
             //No Transaction while inserting record or set of records
                returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.None);
            
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.TSNT);
               
             
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>  
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <param name="transaction"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[],System.Int32)">
             <summary>
              Executes the non query operation.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             
               //QUERY WITH PARAMETER
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(@aColName)";
                WD.DataAccess.Parameters.DBParameter[] aParams= new WD.DataAccess.Parameters.DBParameter[1]
                aParams[0]=new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName="aColName";
                aParams[0].ParameterValue="abcd";
               int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.Yes);
               
             //No Transaction while inserting record or set of records
                returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.None);
            
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,aParams,WD.DataAccess.Enums.Transaction.TSNT);
               
             
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>  
             <exception cref="T:System.Exception">    Thrown when an exception error condition occurs. </exception>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) Collection of Optional Parameters. </param>
             <param name="transaction">  (Optional) </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,System.Int32)">
             <summary>   Executes the non query operation. </summary>
            
            
             <exception cref="T:System.Exception">    Thrown when an exception error condition occurs. </exception>
            
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="transaction">  (Optional) </param>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             string theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES('12121')";
             
             
             //No Transaction while inserting record or set of records
             int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,WD.DataAccess.Enums.Transaction.None);
             or
             use Transaction while inserting record or set of records
              returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,WD.DataAccess.Enums.Transaction.Yes);
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR,theSql,WD.DataAccess.Enums.Transaction.TSNT);
               
               
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,System.Int32)">
             <summary>
              Executes the non query operation.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             
               
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(@aColName)";
                
               int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,WD.DataAccess.Enums.Transaction.Yes);
               
             //No Transaction while inserting record or set of records
                returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,WD.DataAccess.Enums.Transaction.None);
            
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql,WD.DataAccess.Enums.Transaction.TSNT);
               
             
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks> 
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="transaction"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.String,System.Data.CommandType,System.Int32)">
             <summary>
              Executes the non query operation.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             
               
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES('abc')";
               int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.Yes);
               
             //No Transaction while inserting record or set of records
                returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.None);
            
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1,theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.TSNT);
               
             
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks> 
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="transaction"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.String,System.Data.CommandType,System.Int32)">
             <summary>
              Executes the non query operation.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
             //OPEN QUERY
             
               
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES('abc')";
               int returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.Yes);
               
             //No Transaction while inserting record or set of records
                returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.None);
            
              or
              use Transaction scope while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.TS);
                 or
                 No Transaction scope and database connection transaction while inserting record or set of records
               returnRows=dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, theSql, CommandType.Text,WD.DataAccess.Enums.Transaction.TSNT);
               
             
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks> 
             <exception cref="T:System.Exception">    Thrown when an exception error condition occurs. </exception>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  Open Sql Statement or Procedure Name. </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="transaction">  (Optional) </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkInsert(System.Int32,System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select FirstName from employee",,WD.DataAccess.Transactions.None);
               Dictionary&lt;string,string&gt; cols=new Dictionary&lt;string,string&gt;();
               <!--cols.Add("FirstName","FirstName");-->
              int rowsEffected =dbContext.ICommands.BulkInsert(WD.DataAccess.Databases.BR, 1,dt,"Employee",100,30,cols);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <exception cref="T:System.Exception">    Thrown when an exception error condition occurs. </exception>
             <param name="database">     . </param>
             <param name="index">       . </param>
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
             <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkInsert(System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select FirstName from employee",,WD.DataAccess.Transactions.None);
               Dictionary&lt;string,string&gt; cols=new Dictionary&lt;string,string&gt;();
               <!--cols.Add("FirstName","FirstName");-->
              int rowsEffected =dbContext.ICommands.BulkInsert(WD.DataAccess.Databases.BR,dt,"Employee",100,30,cols);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="dt"></param>
             <param name="tableName"></param>
             <param name="batchSize"></param>
             <param name="timeOut"></param>
             <param name="columnNames"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkInsert(System.Int32,System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select FirstName from employee",,WD.DataAccess.Transactions.None);
               Dictionary&lt;string,string&gt; cols=new Dictionary&lt;string,string&gt;();
               <!--cols.Add("FirstName","FirstName");-->
              int rowsEffected =dbContext.ICommands.BulkInsert(WD.DataAccess.Databases.BR, 1,dt,"Employee",100,30,cols,WD.DataAccess.Transactions.None);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="dt"></param>
             <param name="tableName"></param>
             <param name="batchSize"></param>
             <param name="timeOut"></param>
             <param name="columnNames"></param>
             <param name="transaction"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkInsert(System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
             <summary>   Bulk insert. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select FirstName from employee",,WD.DataAccess.Transactions.None);
               Dictionary&lt;string,string&gt; cols=new Dictionary&lt;string,string&gt;();
               <!--cols.Add("FirstName","FirstName");-->
              int rowsEffected =dbContext.ICommands.BulkInsert(WD.DataAccess.Databases.BR,dt,"Employee",100,30,cols,WD.DataAccess.Transactions.None);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="dt"></param>
             <param name="tableName"></param>
             <param name="batchSize"></param>
             <param name="timeOut"></param>
             <param name="columnNames"></param>
             <param name="transaction"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkUpdate(System.Int32,System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;();
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
              int rowsEffected =dbContext.ICommands.BulkUpdate(WD.DataAccess.Databases.BR, 1,dt,"Employee",100,30,columnNames,primaryColumns);
             }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>
             <param name="index" >  index number of database. </param>
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated. </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param> 
             <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkUpdate(System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;();
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
              int rowsEffected =dbContext.ICommands.BulkUpdate(WD.DataAccess.Databases.BR,dt,"Employee",100,30,columnNames,primaryColumns);
             }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>       
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated. </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param> 
             <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkUpdate(System.Int32,System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
             <summary>   Bulk update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;();
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
              int rowsEffected =dbContext.ICommands.BulkUpdate(WD.DataAccess.Databases.BR, 1,dt,"Employee",100,30,columnNames,primaryColumns,WD.DataAccess.Transactions.None);
             }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>
             <param name="index" >  index number of database. </param>
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated. </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param> 
             <param name="transaction"> (Optional)No Transaction for Database </param>
             <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkUpdate(System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
             <summary>   Bulk update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;();
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
              int rowsEffected =dbContext.ICommands.BulkUpdate(WD.DataAccess.Databases.BR,dt,"Employee",100,30,columnNames,primaryColumns,WD.DataAccess.Transactions.None);
             }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>       
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="columnNames"> Column list which represents the Set options (columns) for records to be updated. </param>
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param> 
             <param name="transaction"> (Optional)No Transaction for Database </param>
             <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkDelete(System.Int32,System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id from employee");
               Dictionary&lt;string,string&gt; primaryColumns=new Dictionary&lt;string,string&gt;();
               primaryColumns.Add("Id","Id");
              int rowsEffected =dbContext.ICommands.BulkDelete(WD.DataAccess.Databases.BR,1,dt,"Employee",100,30,primaryColumns);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>
             <param name="index" > index number of database. </param>
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>   
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkDelete(System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>   Bulk delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id from employee");
               Dictionary&lt;string,string&gt; primaryColumns=new Dictionary&lt;string,string&gt;();
               primaryColumns.Add("Id","Id");
              int rowsEffected =dbContext.ICommands.BulkDelete(WD.DataAccess.Databases.BR,dt,"Employee",100,30,primaryColumns);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>  
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkDelete(System.Int32,System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
             <summary>   Bulk delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id from employee");
               Dictionary&lt;string,string&gt; primaryColumns=new Dictionary&lt;string,string&gt;();
               primaryColumns.Add("Id","Id");
              int rowsEffected =dbContext.ICommands.BulkDelete(WD.DataAccess.Databases.BR,1,dt,"Employee",100,30,primaryColumns,WD.DataAccess.Transactions.None);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>
             <param name="index" >  index number of database. </param>
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>      
             <param name="transaction"> (Optional)No Transaction for Database </param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.BulkDelete(System.Int32,System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
             <summary>   Bulk delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               DataTable dt =dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"select Id from employee");
               Dictionary&lt;string,string&gt; primaryColumns=new Dictionary&lt;string,string&gt;();
               primaryColumns.Add("Id","Id");
              int rowsEffected =dbContext.ICommands.BulkDelete(WD.DataAccess.Databases.BR,dt,"Employee",100,30,primaryColumns,WD.DataAccess.Transactions.None);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> WD.DataAccess.Enums.</param>
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Column list which represents the Where clause filters. </param>      
             <param name="transaction"> (Optional)No Transaction for Database </param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteScalar(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the Scalar operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               string firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, "Select FirstName from employee where EmployeeId=1");
               
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue="1";
               firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, "Select FirstName from employee where EmployeeId=@EmployeeId", aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   An object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteScalar(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the Scalar operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               string firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1, "Select FirstName from employee where EmployeeId=1");
               
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue="1";
               firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1, "Select FirstName from employee where EmployeeId=@EmployeeId", aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteScalar(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the Scalar operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               string firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR,  "Select FirstName from employee where EmployeeId=1", CommandType.Text);
               
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue="1";
               firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR,  "Select FirstName from employee where EmployeeId=@EmployeeId", CommandType.Text, aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="commandType">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   An object. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteScalar(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the Scalar operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               string firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1, "Select FirstName from employee where EmployeeId=1", CommandType.Text);
               
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="EmployeeId";
               aParams[0].ParameterValue="1";
               firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1, "Select FirstName from employee where EmployeeId=@EmployeeId", CommandType.Text, aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data table operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataTable dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"Select columnNames from tableName");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Databases.BR,"Select columnNames from tableName where FirstName=@FirstName",aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   A DataTable. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data Table operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataTable dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data Table operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataTable dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR,"Select columnNames from tableName",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
            
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="commandType">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   A DataTable. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data Table operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataTable dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               dt=dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data set operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataSet ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,"Select columnNames from tableName");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,"Select columnNames from tableName where FirstName=@FirstName",aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
            
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   A DataSet. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data set operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataSet ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enum.Databases.BR, 1,"Select columnNames from tableName");
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data set operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataSet ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,"Select columnNames from tableName",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="commandType">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   A DataSet. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data set operation. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
              DataSet ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName",CommandType.Text);
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
                ds=dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteRecordSet(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the record set operation. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Databases.BR,"Select columnNames from tableName")){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Databases.BR,"Select columnNames from tableName
               where FirstName=@FirstName",aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="aParams">      (Optional) </param>
             <returns>   An ADODB.Recordset. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteRecordSet(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the record set operation. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName")){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName
               where FirstName=@FirstName",aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteRecordSet(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the record set operation. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Databases.BR,"Select columnNames from tableName",CommandType.Text)){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Databases.BR,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="commandType">  . </param>
             <param name="aParams">      (Optional) </param>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteRecordSet(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the record set operation. </summary>
            
             <remarks>    </remarks>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName",CommandType.Text)){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(ADODB.Recordset recordSet=dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data reader operation. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Databases.BR,"Select columnNames from tableName")){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Databases.BR,"Select columnNames from tableName
               where FirstName=@FirstName",aParams);{
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="aParams">      (Optional) . </param>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Int32,System.Int32,System.String,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data reader operation. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName")){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",aParams)){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data reader operation. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, "Select columnNames from tableName ",CommandType.Text)){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, "Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams)){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
            
             <param name="database">     TX OR BX FOR MITEC. </param>
             <param name="commandText">  . </param>
             <param name="commandType">  CommandType for Text or StoredProcedure (1 or 4) </param>
             <param name="aParams">      (Optional) . </param>
             <returns>   An IDataReader. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Int32,System.Int32,System.String,System.Data.CommandType,WD.DataAccess.Parameters.DBParameter[])">
             <summary>   Executes the data reader operation. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName",CommandType.Text)){
                 //write your code
                  
               }
               //or
               WD.DataAccess.Parameters.DBParameter[] aParams=new WD.DataAccess.Parameters.DBParameter[1];
               aParams[0]=new WD.DataAccess.Parameters.DBParameter();
               aParams[0].ParameterName="FirstName";
               aParams[0].ParameterValue="first name";
               using(IDataReader reader=dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1,"Select columnNames from tableName where FirstName=@FirstName",CommandType.Text,aParams)){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"></param>
             <param name="index"></param>
             <param name="commandText"></param>
             <param name="commandType"></param>
             <param name="aParams"></param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.CreateConnection(System.Int32)">
             <summary>   Creates instance of Connection MITEC database </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection con=dbContext.ICommands.CreateConnection(WD.DataAccess.Databases.BR)){
                 //write code for the connection
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
            
             <param name="database"> TX OR BR. Value of WD.DataAccess.Enums.Databases </param>
            
             <returns>   The new connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.CreateConnection(System.Int32,System.Int32)">
             <summary>   Creates instance of Connection MITEC database </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection con=dbContext.ICommands.CreateConnection(WD.DataAccess.Databases.Enums.BR, 1)){
                 //write code for the connection
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
            
             <param name="database"> TX OR BR. Value of WD.DataAccess.Enums.Databases </param>
             <param name="index"> Databse instance: 1=BR1/TX1 or 2=BR2/TX2 </param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.CreateOpenConnection(System.Int32)">
             <summary>   Creates open connection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection con=dbContext.ICommands.CreateOpenConnection(WD.DataAccess.Databases.BR)){
                 //write code for the connection
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
            
             <param name="database"> TX OR BR. Value of WD.DataAccess.Enums.Databases </param>
            
             <returns>   The new open connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.CreateOpenConnection(System.Int32,System.Int32)">
             <summary>   Creates open connection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
               using(IDbConnection con=dbContext.ICommands.CreateOpenConnection(WD.DataAccess.Databases.BR)){
                 //write code for the connection
               }
             }
             }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             <param name="database"> TX OR BR. Value of WD.DataAccess.Enums.Databases </param>
             <param name="index">Databse instance: 1=BR1/TX1 or 2=BR2/TX2 </param>
             <returns></returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "INSERT INTO TABLE XYX(XYCOLUMN) VALUES('12121')";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // databaseand command object
                int returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1, dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(@aColName)";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "aColName";
                aParams[0].ParameterValue = "abcd";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1, dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Int32,System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "INSERT INTO TABLE XYX(XYCOLUMN) VALUES('12121')";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // databaseand command object
                int returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1, dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql ="INSERT INTO TABLE XYX(XYCOLUMN) VALUES(@aColName)";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "aColName";
                aParams[0].ParameterValue = "abcd";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                returnRows = dbContext.ICommands.ExecuteNonQuery(WD.DataAccess.Enums.Databases.BR, 1, dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Data.IDbCommand,System.Data.IDbTransaction)">
            <summary>
            Executes the non query.
            </summary>
            <param name="command">The command.</param>
            <param name="dbTransaction">The database transaction.</param>
            <returns>System.Int32.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteNonQuery(System.Data.IDbCommand,System.Data.IDbConnection)">
            <summary>
            Executes the non query.
            </summary>
            <param name="command">The command.</param>
            <param name="dbConnection">The database connection.</param>
            <returns>System.Int32.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteScalar(System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select FirstName from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                string firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql = "Select FirstName from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteScalar(System.Int32,System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select FirstName from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                string firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql = "Select FirstName from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                firstName = (string)dbContext.ICommands.ExecuteScalar(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                DataTable dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Int32,System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                DataTable dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // database and command object
                dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataTable(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Data.IDbCommand,System.Data.IDbTransaction)">
            <summary>
            Executes the data table.
            </summary>
            <param name="command">The command.</param>
            <param name="dbTransaction">The database transaction.</param>
            <returns>DataTable.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataTable(System.Data.IDbCommand,System.Data.IDbConnection)">
            <summary>
            Executes the data table.
            </summary>
            <param name="command">The command.</param>
            <param name="dbConnection">The database connection.</param>
            <returns>DataTable.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                DataSet dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Int32,System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                DataSet dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR,dbCommand);
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                dt = dbContext.ICommands.ExecuteDataSet(WD.DataAccess.Enums.Databases.BR, 1,dbCommand);
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Data.IDbCommand,System.Data.IDbTransaction)">
            <summary>
            Executes the data set.
            </summary>
            <param name="command">The command.</param>
            <param name="dbTransaction">The database transaction.</param>
            <returns>DataSet.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataSet(System.Data.IDbCommand,System.Data.IDbConnection)">
            <summary>
            Executes the data set.
            </summary>
            <param name="command">The command.</param>
            <param name="dbConnection">The database connection.</param>
            <returns>DataSet.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteRecordSet(System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                }     
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                } 
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteRecordSet(System.Int32,System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                }     
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                } 
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (ADODB.Recordset recordSet = dbContext.ICommands.ExecuteRecordSet(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                }     
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                } 
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Int32,System.Int32,System.Data.IDbCommand)">
            <example>
             <code>
             class Program
            {
              static void Main()
              {
                 WD.DataAccess.Context.DbContext dbContext = new WD.DataAccess.Context.DbContext(false);
                 //OPEN QUERY
                 string theSql = "Select columnNames from employee where EmployeeId=1";
            
                IDbCommand dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text);
            
                // database and command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                }     
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
                //QUERY WITH PARAMETER
                theSql = "Select columnNames from employee where EmployeeId=@EmployeeId";
                WD.DataAccess.Parameters.DBParameter[] aParams = new WD.DataAccess.Parameters.DBParameter[1];
                aParams[0] = new WD.DataAccess.Parameters.DBParameter();
                aParams[0].ParameterName = "EmployeeId";
                aParams[0].ParameterValue = "1";
            
                dbCommand = dbContext.ICommands.CreateCommand(theSql, CommandType.Text, aParams);
                // databaseand command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, dbCommand))
                {
                     //Your code here
                } 
                //or
                // databse (BR/TX), Databse instance(1=BR1/TX1 or 2=BR2/TX2) and command object
                using (IDataReader reader = dbContext.ICommands.ExecuteDataReader(WD.DataAccess.Enums.Databases.BR, 1, dbCommand))
                {
                     //Your code here
                } 
            
              }
            
            }
             </code>
            </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             <appSettings>//
              <add key="ConnectionsFile" value="E:\XX\XXX.xml" /> //
             </appSettings>//
             <xml>//
             <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	<INSTANCES NAME="SITP">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
              <INSTANCES NAME="SITE1">//
                <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE" /> //
            	</INSTANCES>//
             </DBCONFIG>//
             </xml>//
              </code>
             </remarks>
             
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Data.IDbCommand,System.Data.IDbTransaction)">
            <summary>
            Executes the data reader.
            </summary>
            <param name="command">The command.</param>
            <param name="dbTransaction">The database transaction.</param>
            <returns>IDataReader.</returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.IMTech.ExecuteDataReader(System.Data.IDbCommand,System.Data.IDbConnection)">
            <summary>
            Executes the data reader.
            </summary>
            <param name="command">The command.</param>
            <param name="dbConnection">The database connection.</param>
            <returns>System.Data.IDataReader.</returns>
        </member>
        <member name="F:WD.DataAccess.Abstract.ICommands.bxConnections">
            <summary>   The bx connections. </summary>
        </member>
        <member name="F:WD.DataAccess.Abstract.ICommands.txConnections">
            <summary>   The tx connections. </summary>
        </member>
        <member name="F:WD.DataAccess.Abstract.ICommands.connectionString">
            <summary>   Private connection String. </summary>
        </member>
        <member name="F:WD.DataAccess.Abstract.ICommands.connection">
            <summary>   Private Connection. </summary>
        </member>
        <member name="F:WD.DataAccess.Abstract.ICommands.dbProvider">
            <summary>
            Private DBProvider.
            </summary>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.#ctor">
            <summary>   Initializes a new instance of the <see cref="T:WD.DataAccess.Abstract.ICommands"/> // class. </summary>
            <example>
            This sample shows how to initialize <see cref="T:WD.DataAccess.Abstract.ICommands"/> //.
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext().ICommands;
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient"/> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.#ctor(System.Int32)">
            <summary>   Initialized ICommands By DBProvider. </summary>
            <example>
            This sample shows how to initialize <see cref="M:WD.DataAccess.Abstract.ICommands.#ctor(System.Int32)"/> //.
            <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext(WD.DataAccess.Enums.Sql).ICommands;
            }
            }
            </code>
            </example>
            <remarks>Default providers are maintains Connection Strings in DataAccess Layer.
            </remarks>
            <param name="dbProvider">   SQL,Oracle,Oracle2,Db2,TeraData. </param>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.#ctor(System.Int32,System.String)">
             <summary>   Initialized ICommands By DBProvider and ConnectionString. </summary>
             <example>
             This sample shows how to initialize <see cref="M:WD.DataAccess.Abstract.ICommands.#ctor(System.Int32,System.String)"/> //.
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext(WD.DataAccess.Enums.Sql,"AppSettingKey").ICommands;
             }
             }
             </code>
             </example>
             <remarks>Application should have encrypted connection string in app settings with token name which we are passing as parameter.
            <code>
             <appSettings>//
              <add key="AppSettingKey" value="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"/> //
             </appSettings>//
             </code>
             </remarks>
             <param name="dbProvider">       SQL,Oracle,Oracle2,Db2,TeraData. </param>
             <param name="connectionString"> Encrypted ConnectionString. </param>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Initialized ICommands By Connect Class. </summary>
             <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Helpers.Connect aConnect=new WD.DataAccess.Helpers.Connect();
             aConnect.ConnectionName="testConnection";
             aConnect.DbProvider=WD.DataAccess.Enums.Sql;
             WD.DataAccess.Abstract.ICommands command=new WD.DataAccess.Context.DbContext(aConnect).ICommands;
             //or
             aConnect.ConnectionString="Data Source=XXXXX;User Id=XXX;Password=XXX";
             aConnect.DbProvider=WD.DataAccess.Enums.Sql;
             command =new WD.DataAccess.Context.DbContext(aConnect).ICommands;
             
             }
             }
             </code>
             </example>
             <remarks>Connection string in web.config or App.config.
            <code>
             <connectionStrings>//
             <add name="testConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient" /> //
             </connectionStrings>//
             </code>
             </remarks>
            
             <param name="aConnect"> a connect. </param>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Initializes a new instance of the <see cref="T:WD.DataAccess.Abstract.ICommands"/> // class. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         a connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The tx connections. </param>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CreateOpenConnection">
             <summary>   Creates instance of Open Connection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateOpenConnection()){
                 //write code for the connection
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <returns>   The new open connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CreateOpenConnection(System.Data.IDbConnection)">
             <summary>   Creates the open connection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection()){
                 //opens connection
                  dbContext.ICommands.CreateOpenConnection(con);
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connection">   The connection. </param>
            
             <returns>   IDbConnection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CloseConnection">
             <summary>   Closes current connection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateOpenConnection()){
                 //closes default connection
                  dbContext.ICommands.CloseConnection();
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CreateConnection">
             <summary>   Creates  instance of Connection. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection()){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <returns>   The new connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CreateConnection(System.String)">
             <summary>   Creates  instance of  Connection for connection string passed. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateConnection("DataSource=XXX;UserId=XXX;Password=XXX")){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
            
             <returns>   The new connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CreateOpenConnection(System.String)">
             <summary>   Creates  instance of  Connection for connection string passed. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection con=dbContext.ICommands.CreateOpenConnection("DataSource=XXX;UserId=XXX;Password=XXX")){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
            
             <returns>   The new open connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.CreateAdapter">
             <summary>   Creates the adapter. </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDataAdapter dbAdapter=dbContext.ICommands.CreateAdapter()){
                 //write your code
                  
               }
             }
             }
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <returns>   IDataAdapter. </returns>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.Dispose">
             <summary>   Disposes this instance. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Abstract.ICommands.Dispose(System.Boolean)">
             <summary>   Releases unmanaged and - optionally - managed resources. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="disposing">    <c>true</c> to release both managed and unmanaged resources;
                                         <c>false</c> to release only unmanaged resources. </param>
        </member>
        <member name="P:WD.DataAccess.Abstract.ICommands.Connection">
             <summary>   Default Connection once DbContext gets initialized. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
                 ICommands command=new DbContext().ICommands;
                 IDbConnection con =command.Connection;
             
             }
             }
             </code>
            </example>
             <value> Returns initialized Connection. </value>
        </member>
        <member name="P:WD.DataAccess.Abstract.ICommands.DBProvider">
            <summary>
            Default DBProvider once DbContext gets initialized.
            </summary>
            <example>
            <code>
            class TestClass
            {
            static void Main()
            {
                ICommands command=new DbContext().ICommands;
                int dbProvider =command.DBProvider;
                ///  1 = Sql;
                /// 2= DB2;
                ///3 = Oracle ;Client required
                /// 4= Oracle 2; Oracle managed access dll required
                //5= TeraData
            }
            }
            </code>
            </example>
            <value>The database provider.</value>
        </member>
        <member name="P:WD.DataAccess.Abstract.ICommands.BXConnection">
            <summary>
            Gets the bx connection.
            </summary>
            <value>The bx connection.</value>
        </member>
        <member name="P:WD.DataAccess.Abstract.ICommands.TXConnection">
             <summary>   Gets the tx connection. </summary>
            
             <value> The tx connection. </value>
        </member>
        <member name="P:WD.DataAccess.Abstract.ICommands.IsDispose">
             <summary>   Gets or sets a value indicating whether this instance is dispose. </summary>
            
             <value> <c>true</c> if this instance is dispose; otherwise, <c>false</c>. </value>
        </member>
        <member name="T:WD.DataAccess.Concrete.Db2Database">
             <summary>   A database 2 database. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Concrete.Db2Database.#ctor(System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.Db2Database.#ctor(System.String,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
             <param name="dbProvider">       . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.Db2Database.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.Db2Database.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         . </param>
             <param name="bxConnections">    . </param>
             <param name="txConnections">    The transmit connections. </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.MySqlDatabase.#ctor(System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.MySqlDatabase.#ctor(System.String,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
             <param name="dbProvider">       . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.MySqlDatabase.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.MySqlDatabase.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         . </param>
             <param name="bxConnections">    . </param>
             <param name="txConnections">    . </param>
        </member>
        <member name="T:WD.DataAccess.Concrete.OracleDatabase">
             <summary>   An oracle database. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.#ctor(System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.#ctor(System.String,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         . </param>
             <param name="bxConnections">    . </param>
             <param name="txConnections">    The transmit connections. </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.BulkInsert(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk insert. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
             <param name="connection">   . </param>
             <param name="transaction">  . </param>
            
             <returns>   An int. </returns>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.BulkUpdate(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk Update. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction transaction=con.BeginTransaction())
               {  
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id,FirstName,LastName from employee",connection);
               Dictionary&lt;string,string&gt; columnNames=new Dictionary&lt;string,string&gt;();
               columnNames.Add("FirstName","FirstName");
               columnNames.Add("LastName","LastName");
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkUpdate(dt,"Employee",100,30,columnNames,primaryColumns,connection,transaction);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }  
             } 
             }  
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param>
             <param name="columnNames"> Represents the Set options for records to be updated. </param>
             <param name="primaryColumns"> Represents the Where clause filters. </param>
             <param name="connection"> Active Connection Object . </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Concrete.OracleDatabase.BulkDelete(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk Delete. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
               WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
               using(IDbConnection connection=dbContext.ICommands.CreateConnection())
               {
               using(IDbTransaction transaction=con.BeginTransaction())
               {  
               Try
               {
               DataTable dt =dbContext.ICommands.ExecuteDataTable("select Id from employee",connection);
               Dictionary&lt;string, string&gt; primaryColumns = new Dictionary&lt;string, string&gt;();
               primaryColumns.Add("Id", "Id");
               int rowsEffected =dbContext.ICommands.BulkDelete(dt,"Employee",100,30,primaryColumns,connection,transaction);//
               transaction.Commit();
               }
              catch
              {
                 trans.Rollback();
              }
             }  
             } 
             }  
             }  
             </code>
            </example> 
             <param name="dt"> Data Table which contains data. </param>
             <param name="tableName"> Name of the Table of database. </param>
             <param name="batchSize"> Size of batch to be processed. </param>
             <param name="timeOut">  Time out value in seconds for command execution. </param> 
             <param name="primaryColumns"> Represents the Where clause filters. </param>
             <param name="connection"> Active Connection Object . </param>
             <param name="transaction">  Active Transaction Object. </param>
            
             <returns>   No Of Rows Affected. </returns>
        </member>
        <member name="M:WD.DataAccess.Concrete.PostgreSQLDatabase.#ctor(System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.PostgreSQLDatabase.#ctor(System.String,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
             <param name="dbProvider">       . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.PostgreSQLDatabase.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.PostgreSQLDatabase.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         . </param>
             <param name="bxConnections">    . </param>
             <param name="txConnections">    The transmit connections. </param>
        </member>
        <member name="T:WD.DataAccess.Concrete.SqlDatabase">
             <summary>   A SQL database. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Concrete.SqlDatabase.#ctor(System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.SqlDatabase.#ctor(System.String,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
             <param name="dbProvider">       . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.SqlDatabase.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.SqlDatabase.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         . </param>
             <param name="bxConnections">    . </param>
             <param name="txConnections">    The transmit connections. </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.SqlDatabase.BulkInsert(System.Data.DataTable,System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},System.Data.IDbConnection,System.Data.IDbTransaction)">
             <summary>   Bulk insert. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dt">           . </param>
             <param name="tableName">    . </param>
             <param name="batchSize">    . </param>
             <param name="timeOut">      . </param>
             <param name="columnNames">  . </param>
             <param name="connection">   . </param>
             <param name="transaction">  . </param>
            
             <returns>   An int. </returns>
        </member>
        <member name="T:WD.DataAccess.Concrete.TeraDatabase">
             <summary>   A tera database. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Concrete.TeraDatabase.#ctor(System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.TeraDatabase.#ctor(System.String,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> . </param>
             <param name="dbProvider">       . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.TeraDatabase.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
        </member>
        <member name="M:WD.DataAccess.Concrete.TeraDatabase.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         . </param>
             <param name="bxConnections">    . </param>
             <param name="txConnections">    . </param>
        </member>
        <member name="T:WD.DataAccess.Configurations.AppConfiguration">
             <summary>   An application configuration. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.CreateDataAdapter(System.Int32)">
             <summary>   Creates data adapter. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
            
             <returns>   The new data adapter. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetConnectionString(System.String)">
             <summary>   Gets connection string. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionName">   . </param>
            
             <returns>   The connection string. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetConnectionString(WD.DataAccess.Helpers.Connect)">
             <summary>   Gets connection string. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect"> . </param>
            
             <returns>   The connection string. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetAppSetting(System.String)">
             <summary>   Gets application setting. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="appKey">   . </param>
            
             <returns>   The application setting. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.Decrypt(System.String)">
             <summary>   Decrypts. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="text"> . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetDbProvider(System.String)">
             <summary>   Gets database provider. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionName">   . </param>
            
             <returns>   The database provider. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetDefaultConnectionString">
             <summary>   Gets default connection string. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <returns>   The default connection string. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetDefaultConnectionString(System.String)">
             <summary>   Gets default connection string. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionName">   . </param>
            
             <returns>   The default connection string. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.CreateConnection(System.Int32)">
             <summary>   Creates a connection. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
            
             <returns>   The new connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.CreateConnection(System.String)">
             <summary>   Creates a connection. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="providerName"> . </param>
            
             <returns>   The new connection. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.GetFactory(System.Int32)">
             <summary>   Creates a command. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
            
             <returns>   The new command. </returns>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.LoadFactory``1(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets the t. </summary>
            
             <value> The t. </value>
            
             ### <typeparam name="T">    . </typeparam>
            
             ### <param name="aConnect">         . </param>
             ### <param name="bxConnections">    . </param>
             ### <param name="txConnections">    . </param>
        </member>
        <member name="M:WD.DataAccess.Configurations.AppConfiguration.LoadFactory``1(System.String,System.Int32)">
             <summary>   Gets the t. </summary>
            
             <value> The t. </value>
            
             ### <typeparam name="T">    . </typeparam>
            
             ### <param name="connectionString"> . </param>
             ### <param name="dbProvider">       . </param>
        </member>
        <member name="T:WD.DataAccess.Context.DbContext">
            <summary>
            DbContext is main class which helps in initializing ICommands interface.
            </summary>
            <seealso cref="T:System.IDisposable"/> //
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="F:WD.DataAccess.Context.DbContext.databases">
            <summary>
            The databases.
            </summary>
        </member>
        <member name="F:WD.DataAccess.Context.DbContext.xmlFilePath">
            <summary>
            Full pathname of the XML file.
            </summary>
        </member>
        <member name="F:WD.DataAccess.Context.DbContext.xmlFileName">
            <summary>
            
            </summary>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.Constructor(System.String,System.Int32)">
            <summary>
            This method initializes ICommands as per the connection string and DbProvider.
            </summary>
            <param name="connectionString">.</param>
            <param name="provider">.</param>
            <example>
            This sample shows how to call the <see cref="M:WD.DataAccess.Context.DbContext.Constructor(System.String,System.Int32)"/> // method.
            <code>
            class TestClass
            {
            static void Main()
            {
            string connectionString ="DataSource =XXXXX;UserId=XXX;Password=XXXX";
            WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
            dbContext.Constructor(connectionString, WD.DataAccess.Enums.DBProvider.Sql);
            }
            }
            </code>
            </example>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor">
            <summary>   Default constructor. </summary>
            <example>
            This sample shows how to initialize <see cref="T:WD.DataAccess.Context.DbContext"/> //.
             <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext();
            }
            }
            </code>
            </example>
            <remarks>Before we initialize default constructor we should have connection string with the name DefaultConnection
            <code>
             <connectionStrings>//
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient"/> //
             </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(System.String)">
            <summary>
            Creating Instance of DBContext using connectionName
            </summary>
            <param name="connectionName">   Name of the connection. </param>
            <example>
            This sample shows how to initialize <see cref="!:DbContext(string connectionName)"/> //.
            <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext("testConnection");
            }
            }
            </code>
            </example>
            <remarks>We should have connection string with the name we passing for DbContext initialization.
            <code>
             <connectionStrings>//
            <add name="testConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient"/> //
            <add name="DefaultConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient"/> //
            </connectionStrings>//
            </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(System.Int32)">
            <summary>
            Creating Instance of DBContext using DBProvider (WD.DataAccess.Enums.Sql ,WD.DataAccess.Enums.Oracle,WD.DataAccess.Enums.Oracle2,WD.DataAccess.Enums.Db2 or WD.DataAccess.Enums.TeraData)
            </summary>
            <param name="dbProvider">WD.DataAccess.Enums.Sql ,WD.DataAccess.Enums.Oracle,WD.DataAccess.Enums.Oracle2,WD.DataAccess.Enums.Db2 or WD.DataAccess.Enums.TeraData</param>
            <example>
            This sample shows how to initialize <see cref="!:DbContext(int dbProvider)"/> //.
            <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(WD.DataAccess.Enums.Sql);
            }
            }
            </code>
            </example>
            <remarks>Default providers are maintains Connection Strings in DataAccess Layer.
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(System.Int32,System.String)">
             <summary>
             Creating Instance of DBContext using DBProvider (WD.DataAccess.Enums.Sql ,WD.DataAccess.Enums.Oracle,WD.DataAccess.Enums.Oracle2,WD.DataAccess.Enums.Db2 or WD.DataAccess.Enums.TeraData) and AppkeyName
             </summary>
             <param name="dbProvider">WD.DataAccess.Enums.Sql ,WD.DataAccess.Enums.Oracle,WD.DataAccess.Enums.Oracle2,WD.DataAccess.Enums.Db2 or WD.DataAccess.Enums.TeraData</param>
             <param name="tokenName">tokeName</param>
             <example>
             This sample shows how to initialize <see cref="!:DbContext(int dbProvider, string tokenName)"/> //.
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(WD.DataAccess.Enums.Sql,"AppSettingKey");
             }
             }
             </code>
             </example>
             <remarks>Application should have encrypted connection string in app settings with token name which we are passing as parameter.
            <code>
             <appSettings>//
              <add key="AppSettingKey" value="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"/> //
             </appSettings>//
             </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(WD.DataAccess.Helpers.Connect)">
             <summary>
             Creating Instance of DBContext using Connect With Options dbProvider= (WD.DataAccess.Enums.Sql ,WD.DataAccess.Enums.Oracle,WD.DataAccess.Enums.Oracle2,WD.DataAccess.Enums.Db2 or WD.DataAccess.Enums.TeraData) 
             ,ConnectionName or ConnectionString.
             </summary>
             <param name="aConnect">.</param>
             <example>
             This sample shows how to initialize <see cref="!:DbContext(Connect aConnect)"/> //.
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Helpers.Connect aConnect=new WD.DataAccess.Helpers.Connect();
             aConnect.ConnectionName="testConnection";
             aConnect.DbProvider=WD.DataAccess.Enums.Sql;
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(aConnect);
             //or
             aConnect.ConnectionString="Data Source=XXXXX;User Id=XXX;Password=XXX";
             aConnect.DbProvider=WD.DataAccess.Enums.Sql;
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(aConnect);
             
             }
             }
             </code>
             </example>
             <remarks>Connection string in web.config or App.config.
            <code>
             <connectionStrings>//
             <add name="testConnection" connectionString="Data Source=XXXXX;User Id=XXX;Password=XXX" providerName="System.Data.SqlClient"/> //
             </connectionStrings>//
             </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(System.Boolean)">
             <summary>   Creating Instance of DBContext using boolean flag. </summary>
             <param name="isBackUp"> True if this object needs back up of config.xml. </param>
              <example>
             This sample shows how to initialize <see cref="!:DbContext(bool isBackUp)"/> //.
             <code>
             class TestClass
             {
             static void Main()
             {
             WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext(false);
            
             }
             }
             </code>
             </example>
             <remarks>
             We should have config.xml and its path defined in App settings before DbContext initialization.
             <code>
             
             <appSettings>//
                 <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
             </appSettings>//
             
             <xml>//
                     <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            	            <INSTANCES NAME="SITP">//
                               <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                               <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                               <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
                                <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            	            </INSTANCES>//
                     </DBCONFIG>//
             </xml>//  
             </code>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(System.String,System.Int32)">
            <summary>
            Creating Instance of DBContext using siteName as per XML and (WD.DataAccess.Enum.Databases.TX or WD.DataAccess.Enum.Databases.BR).
            </summary>
            <param name="siteName"> Name of the site. </param>
            <param name="database"> WD.DataAccess.Enum.Databases.TX or WD.DataAccess.Enum.Databases.BR</param>
             <example>
            This sample shows how to initialize <see cref="!:DbContext(siteName,database)"/> //.
            <code>
            class TestClass
            {
            static void Main()
            {
            WD.DataAccess.Context.DbContext dbContext=new WD.DataAccess.Context.DbContext("SITE1",WD.DataAccess.Enum.Databases.BR);
            }
            }
            </code>
            </example>
            <remarks>
            We should have config.xml and its path defined in App settings before DbContext initialization.
            <code>
            <appSettings>//
             <add key="ConnectionsFile" value="E:\XX\XXX.xml"/> //
            </appSettings>//
            <xml>//
            <DBCONFIG DEFAULT_DB_SITE="SITP" INVENTORY_FLAG="OFF" TESTERID_CHECK="OFF" IMPORT_DRIVE="OFF" USE_SERVER_TXCONFIG="FALSE" USE_SERVER_CONNECTION_TYPE="FALSE">//
            <INSTANCES NAME="SITP">//
               <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
               <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
               <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
               <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            </INSTANCES>//
             <INSTANCES NAME="SITE1">//
               <DB ID="TX1" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
               <DB ID="TX2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
               <DB ID="BR1" DBType="SQL" DBName="WDMBR1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
               <DB ID="BR2" DBType="SQL" DBName="WDMTX1" Server="XXX-XX-XXXXX" CONNECTTYPE="ONLINE"/> //
            </INSTANCES>//
            </DBCONFIG>//
            </xml>//
             </code>
            </remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="siteName"></param>
            <param name="database"></param>
            <param name="isBackUp"></param>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.#ctor(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
            <summary>
            Constructor.
            </summary>
            <param name="aConnect">.</param>
            <param name="bxConnections">.</param>
            <param name="txConnections">.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged
            resources.
            </summary>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.Finalize">
            <summary>
            Finalizer.
            </summary>
            <remarks>NOTE: Leave out the finalizer altogether if this class doesn't own unmanaged resources
            itself, but leave the other methods
            exactly as they are.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged
            resources.
            </summary>
            <param name="disposing">True to release both managed and unmanaged resources; false to
            release only unmanaged resources.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="F:WD.DataAccess.Context.DbContext.dbProvider">
            <summary>
            The database provider.
            </summary>
        </member>
        <member name="F:WD.DataAccess.Context.DbContext.connectionString">
            <summary>
            The connection string.
            </summary>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.QueryDatabaseStatus(System.Int32)">
            <summary>
            Queries database status.
            </summary>
            <param name="database">.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.LoadFromXML(System.String)">
            <summary>
            Loads from XML.
            </summary>
            <param name="dbSite">The database site.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.GetDbSite(System.String,System.String)">
            <summary>
            Gets database site.
            </summary>
            <param name="dbSite">The database site.</param>
            <param name="defaultSite">The default site.</param>
            <returns>The database site.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.OpenFileData">
            <summary>
            Opens file data.
            </summary>
            <returns>A DataSet.</returns>
            <exception cref="T:System.ApplicationException">OpenFile : Could not locate this file</exception>
            <exception cref="T:System.ApplicationException">OpenFile : Could not locate this file</exception>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.GetDatabaseConfig(System.String)">
            <summary>
            Gets database configuration.
            </summary>
            <param name="database">.</param>
            <returns>The database configuration.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.GetDatabaseConfig(System.Int32)">
            <summary>
            Gets database configuration.
            </summary>
            <param name="database">.</param>
            <returns>The database configuration.</returns>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.InitializeDatabase">
            <summary>
            Initializes the database.
            </summary>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.GetActualConnection(System.Int32)">
            <summary>
            Gets actual connection.
            </summary>
            <param name="database">.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.GetConnection(System.Int32)">
            <summary>
            
            </summary>
            <param name="database"></param>
        </member>
        <member name="M:WD.DataAccess.Context.DbContext.SetActualConnection(System.Int32)">
            <summary>
            Sets a connection.
            </summary>
            <param name="database">.</param>
            <remarks>Shahid Kochak, 7/20/2017.</remarks>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.BXConfig">
            <summary>
            The bx configuration.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.TXConfig">
            <summary>
            The transmit configuration.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.dummyId">
            <summary>
            Identifier for the dummy.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.dummyPasswd">
            <summary>
            The dummy password.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.ICommands">
            <summary>
            ICommands Public Field to Access all in build functions.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.isChanged">
            <summary>
            True if this object is changed.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.xmlInstance">
            <summary>
            The XML instance.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.SiteName">
            <summary>
            Name of the site.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.SiteLocation">
            <summary>
            The site location.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.InventoryFlag">
            <summary>
            The inventory flag.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.TesterIdCheck">
            <summary>
            The tester identifier check.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.ImportDrive">
            <summary>
            The import drive.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.UserServerTxConfig">
            <summary>
            The user server transmit configuration.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.UserServerConnectionType">
            <summary>
            Type of the user server connection.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.ReportingDbName">
            <summary>
            Name of the reporting database.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.TimeLog">
            <summary>
            The time log.
            </summary>
        </member>
        <member name="P:WD.DataAccess.Context.DbContext.Config">
            <summary>
            The configuration.
            </summary>
        </member>
        <member name="T:WD.DataAccess.Enums.Transaction">
             <summary>   A transaction. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Enums.Transaction.None">
            <summary> No Transaction for Database. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.Transaction.Yes">
            <summary> Transaction for Connections Separately. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.Transaction.TS">
            <summary>    One Transaction for All Connections without connection Transaction. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.Transaction.TSNT">
            <summary>   One Transaction for All Connections with connection Transaction. </summary>
        </member>
        <member name="M:WD.DataAccess.Enums.Transaction.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Factory.MySqlFactory">
             <summary>   A PostgreSQL factory. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Factory.FactoryBase">
             <summary>   A factory base. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.FactoryBase.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.FactoryBase.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.FactoryBase.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.MySqlFactory.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.MySqlFactory.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="T:WD.DataAccess.Factory.PostgreSQLFactory">
             <summary>   A PostgreSQL factory. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.PostgreSQLFactory.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.PostgreSQLFactory.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="T:WD.DataAccess.Factory.TeraFactory">
             <summary>   A tera factory. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.TeraFactory.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.TeraFactory.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="T:WD.DataAccess.Helpers.ObjectXMLSerializer">
             <summary>   Serialization format types. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Helpers.ObjectXMLSerializer.Binary">
            <summary>
            Binary serialization format.
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ObjectXMLSerializer.Document">
            <summary>
            Document serialization format.
            </summary>
        </member>
        <member name="T:WD.DataAccess.Helpers.ObjectXMLSerializer`1">
             <summary>   An object XML serializer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <typeparam name="T">    . </typeparam>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Load(System.String)">
             <summary>   Loads an object from an XML file in Document format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="path"> Path of the file to load the object from. </param>
            
             <returns>   Object loaded from an XML file in Document format. </returns>
            
             <example>
             <code>
             serializableObject = ObjectXMLSerializer&lt;SerializableObject&gt;.Load(@"C:\XMLObjects.xml");
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Load(System.String,WD.DataAccess.Helpers.ObjectXMLSerializer)">
             <summary>   Loads an object from an XML file using a specified serialized format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="path">             Path of the file to load the object from. </param>
             <param name="serializedFormat"> XML serialized format used to load the object. </param>
            
             <returns>   Object loaded from an XML file using the specified serialized format. </returns>
            
             <example>
             <code>
             serializableObject = ObjectXMLSerializer&lt;SerializableObject&gt;.Load(@"C:\XMLObjects.xml", SerializedFormat.Binary);
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Load(System.String,System.Type[])">
             <summary>
             Loads an object from an XML file in Document format, supplying extra data types to enable
             deserialization of custom types within the object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="path">         Path of the file to load the object from. </param>
             <param name="extraTypes">   Extra data types to enable deserialization of custom types within
                                         the object. </param>
            
             <returns>   Object loaded from an XML file in Document format. </returns>
            
             <example>
             <code>
             serializableObject = ObjectXMLSerializer&lt;SerializableObject&gt;.Load(@"C:\XMLObjects.xml", new Type[] { typeof(MyCustomType) });
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Load(System.String,System.IO.IsolatedStorage.IsolatedStorageFile)">
             <summary>
             Loads an object from an XML file in Document format, located in a specified isolated storage
             area.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="fileName">                 Name of the file in the isolated storage area to load
                                                     the object from. </param>
             <param name="isolatedStorageDirectory"> Isolated storage area directory containing the XML
                                                     file to load the object from. </param>
            
             <returns>
             Object loaded from an XML file in Document format located in a specified isolated storage
             area.
             </returns>
            
             <example>
             <code>
             serializableObject = ObjectXMLSerializer&lt;SerializableObject&gt;.Load("XMLObjects.xml", IsolatedStorageFile.GetUserStoreForAssembly());
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Load(System.String,System.IO.IsolatedStorage.IsolatedStorageFile,WD.DataAccess.Helpers.ObjectXMLSerializer)">
             <summary>
             Loads an object from an XML file located in a specified isolated storage area, using a
             specified serialized format.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="fileName">                 Name of the file in the isolated storage area to load
                                                     the object from. </param>
             <param name="isolatedStorageDirectory"> Isolated storage area directory containing the XML
                                                     file to load the object from. </param>
             <param name="serializedFormat">         XML serialized format used to load the object. </param>
            
             <returns>
             Object loaded from an XML file located in a specified isolated storage area, using a
             specified serialized format.
             </returns>
            
             <example>
             <code>
             serializableObject = ObjectXMLSerializer&lt;SerializableObject&gt;.Load("XMLObjects.xml", IsolatedStorageFile.GetUserStoreForAssembly(), SerializedFormat.Binary);
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Load(System.String,System.IO.IsolatedStorage.IsolatedStorageFile,System.Type[])">
             <summary>
             Loads an object from an XML file in Document format, located in a specified isolated storage
             area, and supplying extra data types to enable deserialization of custom types within the
             object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="fileName">                 Name of the file in the isolated storage area to load
                                                     the object from. </param>
             <param name="isolatedStorageDirectory"> Isolated storage area directory containing the XML
                                                     file to load the object from. </param>
             <param name="extraTypes">               Extra data types to enable deserialization of custom
                                                     types within the object. </param>
            
             <returns>
             Object loaded from an XML file located in a specified isolated storage area, using a
             specified serialized format.
             </returns>
            
             <example>
             <code>
             serializableObject = ObjectXMLSerializer&lt;SerializableObject&gt;.Load("XMLObjects.xml", IsolatedStorageFile.GetUserStoreForAssembly(), new Type[] { typeof(MyCustomType) });
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Save(`0,System.String)">
             <summary>   Saves an object to an XML file in Document format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">   Serializable object to be saved to file. </param>
             <param name="path">                 Path of the file to save the object to. </param>
            
             <example>
             <code>
             SerializableObject serializableObject = new SerializableObject();
             
             ObjectXMLSerializer&lt;SerializableObject&gt;.Save(serializableObject, @"C:\XMLObjects.xml");
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Save(`0,System.String,WD.DataAccess.Helpers.ObjectXMLSerializer)">
             <summary>   Saves an object to an XML file using a specified serialized format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">   Serializable object to be saved to file. </param>
             <param name="path">                 Path of the file to save the object to. </param>
             <param name="serializedFormat">     XML serialized format used to save the object. </param>
            
             <example>
             <code>
             SerializableObject serializableObject = new SerializableObject();
             
             ObjectXMLSerializer&lt;SerializableObject&gt;.Save(serializableObject, @"C:\XMLObjects.xml", SerializedFormat.Binary);
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Save(`0,System.String,System.Type[])">
             <summary>
             Saves an object to an XML file in Document format, supplying extra data types to enable
             serialization of custom types within the object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">   Serializable object to be saved to file. </param>
             <param name="path">                 Path of the file to save the object to. </param>
             <param name="extraTypes">           Extra data types to enable serialization of custom types
                                                 within the object. </param>
            
             <example>
             <code>
             SerializableObject serializableObject = new SerializableObject();
             
             ObjectXMLSerializer&lt;SerializableObject&gt;.Save(serializableObject, @"C:\XMLObjects.xml", new Type[] { typeof(MyCustomType) });
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Save(`0,System.String,System.IO.IsolatedStorage.IsolatedStorageFile)">
             <summary>
             Saves an object to an XML file in Document format, located in a specified isolated storage
             area.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">       Serializable object to be saved to file. </param>
             <param name="fileName">                 Name of the file in the isolated storage area to save
                                                     the object to. </param>
             <param name="isolatedStorageDirectory"> Isolated storage area directory containing the XML
                                                     file to save the object to. </param>
            
             <example>
             <code>
             SerializableObject serializableObject = new SerializableObject();
             
             ObjectXMLSerializer&lt;SerializableObject&gt;.Save(serializableObject, "XMLObjects.xml", IsolatedStorageFile.GetUserStoreForAssembly());
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Save(`0,System.String,System.IO.IsolatedStorage.IsolatedStorageFile,WD.DataAccess.Helpers.ObjectXMLSerializer)">
             <summary>
             Saves an object to an XML file located in a specified isolated storage area, using a
             specified serialized format.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">       Serializable object to be saved to file. </param>
             <param name="fileName">                 Name of the file in the isolated storage area to save
                                                     the object to. </param>
             <param name="isolatedStorageDirectory"> Isolated storage area directory containing the XML
                                                     file to save the object to. </param>
             <param name="serializedFormat">         XML serialized format used to save the object. </param>
            
             <example>
             <code>
             SerializableObject serializableObject = new SerializableObject();
             
             ObjectXMLSerializer&lt;SerializableObject&gt;.Save(serializableObject, "XMLObjects.xml", IsolatedStorageFile.GetUserStoreForAssembly(), SerializedFormat.Binary);
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.Save(`0,System.String,System.IO.IsolatedStorage.IsolatedStorageFile,System.Type[])">
             <summary>
             Saves an object to an XML file in Document format, located in a specified isolated storage
             area, and supplying extra data types to enable serialization of custom types within the
             object.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">       Serializable object to be saved to file. </param>
             <param name="fileName">                 Name of the file in the isolated storage area to save
                                                     the object to. </param>
             <param name="isolatedStorageDirectory"> Isolated storage area directory containing the XML
                                                     file to save the object to. </param>
             <param name="extraTypes">               Extra data types to enable serialization of custom
                                                     types within the object. </param>
            
             <example>
             <code>
             SerializableObject serializableObject = new SerializableObject();
             
             ObjectXMLSerializer&lt;SerializableObject&gt;.Save(serializableObject, "XMLObjects.xml", IsolatedStorageFile.GetUserStoreForAssembly(), new Type[] { typeof(MyCustomType) });
             </code>
             </example>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.CreateFileStream(System.IO.IsolatedStorage.IsolatedStorageFile,System.String)">
             <summary>   Creates file stream. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
             <param name="path">                     Path of the file to load the object from. </param>
            
             <returns>   The new file stream. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.LoadFromBinaryFormat(System.String,System.IO.IsolatedStorage.IsolatedStorageFile)">
             <summary>   Loads from binary format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="path">                     Path of the file to load the object from. </param>
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
            
             <returns>   The data that was read from the binary format. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.LoadFromDocumentFormat(System.Type[],System.String,System.IO.IsolatedStorage.IsolatedStorageFile)">
             <summary>   Loads from document format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="extraTypes">               Extra data types to enable deserialization of custom
                                                     types within the object. </param>
             <param name="path">                     Path of the file to load the object from. </param>
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
            
             <returns>   The data that was read from the document format. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.CreateTextReader(System.IO.IsolatedStorage.IsolatedStorageFile,System.String)">
             <summary>   Creates text reader. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
             <param name="path">                     Path of the file to load the object from. </param>
            
             <returns>   The new text reader. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.CreateTextWriter(System.IO.IsolatedStorage.IsolatedStorageFile,System.String)">
             <summary>   Creates text writer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
             <param name="path">                     Path of the file to load the object from. </param>
            
             <returns>   The new text writer. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.CreateXmlSerializer(System.Type[])">
             <summary>   Creates XML serializer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="extraTypes">   Extra data types to enable deserialization of custom types within
                                         the object. </param>
            
             <returns>   The new XML serializer. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.SaveToDocumentFormat(`0,System.Type[],System.String,System.IO.IsolatedStorage.IsolatedStorageFile)">
             <summary>   Saves to document format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">       Serializable object to be saved to file. </param>
             <param name="extraTypes">               Extra data types to enable serialization of custom
                                                     types within the object. </param>
             <param name="path">                     Path of the file to save the object to. </param>
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
        </member>
        <member name="M:WD.DataAccess.Helpers.ObjectXMLSerializer`1.SaveToBinaryFormat(`0,System.String,System.IO.IsolatedStorage.IsolatedStorageFile)">
             <summary>   Saves to binary format. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="serializableObject">       Serializable object to be saved to file. </param>
             <param name="path">                     Path of the file to save the object to. </param>
             <param name="isolatedStorageFolder">    Pathname of the isolated storage folder. </param>
        </member>
        <member name="T:WD.DataAccess.Helpers.PagingInfo">
             <summary>   Information about the paging. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Helpers.PagingInfo.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Helpers.PagingInfo.#ctor(System.Int32,System.Int32,System.Int32)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="pageIndex">        . </param>
             <param name="pageSize">         . </param>
             <param name="totalItemCount">   . </param>
        </member>
        <member name="P:WD.DataAccess.Helpers.PagingInfo.PageIndex">
             <summary>   Gets or sets the zero-based index of the page. </summary>
            
             <value> The page index. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.PagingInfo.PageSize">
             <summary>   Gets or sets the size of the page. </summary>
            
             <value> The size of the page. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.PagingInfo.TotalItemCount">
             <summary>   Gets or sets the number of total items. </summary>
            
             <value> The total number of item count. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.PagingInfo.TotalPageCount">
             <summary>   Gets the number of total pages. </summary>
            
             <value> The total number of page count. </value>
        </member>
        <member name="T:WD.DataAccess.Helpers.ItemSpecification">
             <summary>
             The item specification class is used to define the columns contained within the delimited
             file to be opened.  For each column we need to know the data type (and I am using the jet
             data types here), the column number, the column name, data type, and column width (if the
             file is delimited using fixed widths alone) - a list of item specification is added to the
             schema definition trailing this class.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Helpers.ItemSpecification.ColumnNumber">
            <value> The column number. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.ItemSpecification.Name">
            <summary>   Gets or sets the name. </summary>
             the column name
            <value> The name. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.ItemSpecification.TypeData">
            <summary>   Gets or sets information describing the type. </summary>
            the data type
            <value> Information describing the type. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.ItemSpecification.ColumnWidth">
            <summary>   Gets or sets the width of the column. </summary>
            optional column width for fixed width files
            <value> The width of the column. </value>
        </member>
        <member name="T:WD.DataAccess.Helpers.ItemSpecification.JetDataType">
            <summary>   Values that represent jet data types. </summary>
            this enumeration is used to
            limit the type data property to
            a matching jet data type
            <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Bit">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Byte">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Short">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Long">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Currency">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Single">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Double">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.DateTime">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Text">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.ItemSpecification.JetDataType.Memo">
            <summary>
            
            </summary>
        </member>
        <member name="T:WD.DataAccess.Helpers.SchemeDef">
             <summary>
             The schema definition class is used to hold the contents of the schema.ini file used by the
             connection to open a delimited file (using an oledb connection).  The schema dialog is used
             to define a schema definition which is stored as a application property.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Helpers.SchemeDef.#ctor">
             <summary>
             the constructor will create a default comma delimited file definition with an empty list of
             items specifications and will default to set the first row is a header row option to false.
             </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Helpers.SchemeDef.DelimiterType">
            <summary>   Gets or sets the type of the delimiter. </summary>
            The properties used to build the schema.ini file include the
            delimiter type, a custom delimiter (if used), a list of
            column definitions, and a determination as to whether
            the first row of the file contains header information rather
            than data
            <value> The type of the delimiter. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.SchemeDef.CustomDelimiter">
             <summary>   Gets or sets the custom delimiter. </summary>
            
             <value> The custom delimiter. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.SchemeDef.ColumnDefinition">
             <summary>   Gets or sets the column definition. </summary>
            
             <value> The column definition. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.SchemeDef.UsesHeader">
             <summary>   Gets or sets the uses header. </summary>
            
             <value> The uses header. </value>
        </member>
        <member name="T:WD.DataAccess.Helpers.SchemeDef.DelimType">
            <summary>   Values that represent Delimiter types. </summary>
            this enumeration is used to limit the delimiter types
            to one of the four we are interested in which are
            comma delimited, tab delimited, custom delimited
            (such as a pipe or an underscore), or fixed column
            widths
            <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Helpers.SchemeDef.DelimType.CsvDelimited">
            <summary>   An enum constant representing the CSV delimited option. </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.SchemeDef.DelimType.TabDelimited">
            <summary>   An enum constant representing the tab delimited option. </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.SchemeDef.DelimType.CustomDelimited">
            <summary>   An enum constant representing the custom delimited option. </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.SchemeDef.DelimType.FixedWidth">
            <summary>   An enum constant representing the fixed width option. </summary>
        </member>
        <member name="T:WD.DataAccess.Helpers.SchemeDef.FirstRowHeader">
             <summary>   Values that represent first row headers. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Helpers.SchemeDef.FirstRowHeader.Yes">
            <summary>   An enum constant representing the yes option. </summary>
        </member>
        <member name="F:WD.DataAccess.Helpers.SchemeDef.FirstRowHeader.No">
            <summary>   An enum constant representing the no option. </summary>
        </member>
        <member name="T:WD.DataAccess.Mitecs.WDConfig">
             <summary>   (Serializable) a wd configuration. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.DefaultSite">
             <summary>   Gets or sets the default site. </summary>
            
             <value> The default site. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.InventoryFlag">
             <summary>   Gets or sets the inventory flag. </summary>
            
             <value> The inventory flag. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.TesterdIdCheck">
             <summary>   Gets or sets the testerd identifier check. </summary>
            
             <value> The testerd identifier check. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.ImportDrive">
             <summary>   Gets or sets the import drive. </summary>
            
             <value> The import drive. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.UserServerTxConfig">
             <summary>   Gets or sets the user server transmit configuration. </summary>
            
             <value> The user server transmit configuration. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.UserServerConnectionType">
             <summary>   Gets or sets the type of the user server connection. </summary>
            
             <value> The type of the user server connection. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.SqlThrowErrorList">
             <summary>   Gets or sets a list of SQL throw errors. </summary>
            
             <value> A List of SQL throw errors. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDConfig.INSTANCES">
             <summary>   Gets or sets the instances. </summary>
            
             <value> The instances. </value>
        </member>
        <member name="T:WD.DataAccess.Mitecs.Instance">
             <summary>   (Serializable) an instance. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Mitecs.Instance.Name">
             <summary>   Gets or sets the name. </summary>
            
             <value> The name. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.Instance.SiteLocation">
             <summary>   Gets or sets the site location. </summary>
            
             <value> The site location. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.Instance.TimeLog">
             <summary>   Gets or sets the time log. </summary>
            
             <value> The time log. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.Instance.ReportingDbName">
             <summary>   Gets or sets the name of the reporting database. </summary>
            
             <value> The name of the reporting database. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.Instance.Dbs">
             <summary>   Gets or sets the dbs. </summary>
            
             <value> The dbs. </value>
        </member>
        <member name="T:WD.DataAccess.Mitecs.DB">
             <summary>   (Serializable) a database. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Mitecs.DB.ID">
             <summary>   Gets or sets the identifier. </summary>
            
             <value> The identifier. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.DB.DBType">
             <summary>   Gets or sets the type of the database. </summary>
            
             <value> The type of the database. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.DB.DBName">
             <summary>   Gets or sets the name of the database. </summary>
            
             <value> The name of the database. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.DB.Server">
             <summary>   Gets or sets the server. </summary>
            
             <value> The server. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.DB.ConnectType">
             <summary>   Gets or sets the type of the connect. </summary>
            
             <value> The type of the connect. </value>
        </member>
        <member name="T:WD.DataAccess.Mitecs.Connections">
             <summary>   A connections. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Mitecs.Connections.connectionString">
            <summary>   The connection string. </summary>
        </member>
        <member name="M:WD.DataAccess.Mitecs.Connections.#ctor(System.String,System.String)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="servername">   . </param>
             <param name="databaseName"> . </param>
        </member>
        <member name="M:WD.DataAccess.Mitecs.Connections.#ctor(System.String,System.String,System.String,System.String)">
             <summary>   Constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="servername">   . </param>
             <param name="databaseName"> . </param>
             <param name="UserID">       . </param>
             <param name="Password">     . </param>
        </member>
        <member name="M:WD.DataAccess.Mitecs.Connections.ConnectionString">
             <summary>   Connection string. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <returns>   A string. </returns>
        </member>
        <member name="T:WD.DataAccess.Enums.Databases">
             <summary>   A databases. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Enums.Databases.BR">
            <summary>    The BR flag. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.Databases.TX">
            <summary>    The TX flag. </summary>
        </member>
        <member name="M:WD.DataAccess.Enums.Databases.#ctor">
             <summary>    Default constructor. </summary>
            
             <remarks>    Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Mitecs.WDDBConfig">
             <summary>   A WD configuration. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Mitecs.WDDBConfig._index">
            <summary>
            The index
            </summary>
        </member>
        <member name="F:WD.DataAccess.Mitecs.WDDBConfig._dbProvider">
            <summary>   The database provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Mitecs.WDDBConfig._RecoveryFlag">
            <summary>   True to recovery flag. </summary>
        </member>
        <member name="F:WD.DataAccess.Mitecs.WDDBConfig._ActiveFlag">
            <summary>   True to active flag. </summary>
        </member>
        <member name="F:WD.DataAccess.Mitecs.WDDBConfig._ServerName">
            <summary>   Name of the server. </summary>
        </member>
        <member name="F:WD.DataAccess.Mitecs.WDDBConfig._DatabaseName">
            <summary>   Name of the database. </summary>
        </member>
        <member name="M:WD.DataAccess.Mitecs.WDDBConfig.#ctor(System.Int32,System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:WD.DataAccess.Mitecs.WDDBConfig"/> class.
            </summary>
            <param name="index">The index.</param>
            <param name="serverName">Name of the server.</param>
            <param name="databaseName">Name of the database.</param>
            <param name="activeFlag">if set to <c>true</c> [active flag].</param>
            <param name="dbProvider">The database provider.</param>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.Userid">
             <summary>   Gets or sets the userid. </summary>
            
             <value> The userid. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.Password">
             <summary>   Gets or sets the password. </summary>
            
             <value> The password. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.RecoveryFlag">
             <summary>   Gets or sets a value indicating whether the recovery flag. </summary>
            
             <value> True if recovery flag, false if not. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.ActiveFlag">
             <summary>   Gets or sets a value indicating whether the active flag. </summary>
            
             <value> True if active flag, false if not. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.ServerName">
             <summary>   Gets or sets the name of the server. </summary>
            
             <value> The name of the server. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.DatabaseName">
             <summary>   Gets or sets the name of the database. </summary>
            
             <value> The name of the database. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.ErrorMessages">
             <summary>   Gets or sets the error messages. </summary>
            
             <value> The error messages. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.DatabaseTransaction">
             <summary>   Gets or sets the database transaction. </summary>
            
             <value> The database transaction. </value>
        </member>
        <member name="P:WD.DataAccess.Mitecs.WDDBConfig.dbProvider">
             <summary>   Gets or sets the database provider. </summary>
            
             <value> The database provider. </value>
        </member>
        <member name="T:WD.DataAccess.Enums.DBProvider">
             <summary>   Defines different Set of databases. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.Sql">
            <summary>   SQL Database Provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.Db2">
            <summary>   IBM DB2 Database Provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.Oracle">
            <summary>   Oracle Client Database Provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.Oracle2">
            <summary>   Oracle Managed Data Access Provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.TeraData">
            <summary>   TeraData Database Provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.Access">
            <summary>
            Access database provider
            </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.PostgreSQL">
            <summary>
            PostgreSQL Database provider
            </summary>
        </member>
        <member name="F:WD.DataAccess.Enums.DBProvider.MySql">
            <summary>
            PostgreSQL Database provider
            </summary>
        </member>
        <member name="M:WD.DataAccess.Enums.DBProvider.#ctor">
             <summary>   Default constructor. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Factory.Db2Factory">
             <summary>   A database 2 factory. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.Db2Factory.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.Db2Factory.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="T:WD.DataAccess.Factory.OracleFactory">
             <summary>   An oracle factory. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.OracleFactory.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.OracleFactory.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="T:WD.DataAccess.Factory.SqlFactory">
             <summary>   A SQL factory. This class cannot be inherited. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Factory.SqlFactory.GetDataLayer(System.String,System.Int32)">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="connectionString"> The connection string. </param>
             <param name="dbProvider">       The database provider. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="M:WD.DataAccess.Factory.SqlFactory.GetDataLayer(WD.DataAccess.Helpers.Connect,System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig},System.Collections.Generic.List{WD.DataAccess.Mitecs.WDDBConfig})">
             <summary>   Gets data layer. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="aConnect">         The connect. </param>
             <param name="bxConnections">    The bx connections. </param>
             <param name="txConnections">    The transmit connections. </param>
            
             <returns>   The data layer. </returns>
        </member>
        <member name="T:WD.DataAccess.Helpers.Connect">
             <summary>    This class acts as Wrapper for Initializing DbContext. </summary>
            
             <remarks>    Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Helpers.Connect.ConnectionName">
             <summary>
             Connection Name Stored in Connection Settings of Client Application Web.Config or App.Config
             File.
             </summary>
            
             <value> The name of the connection. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.Connect.ConnectionString">
             <summary>   Full Connection String for Client Application. </summary>
            
             <value> The connection string. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.Connect.DbProvider">
             <summary>   Provider Type SQL, Db2, Oracle, Oracle2 or TeraData. </summary>
            
             <value> The database provider. </value>
        </member>
        <member name="T:WD.DataAccess.Helpers.HelperUtility">
             <summary>   A helper utility. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.Truncate(System.String,System.Int32)">
             <summary>   Truncates. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="value">        . </param>
             <param name="maxLength">    . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.GetVersion">
             <summary>   Gets the version. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <returns>   The version. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.Prefix(System.Int32)">
             <summary>   Prefixes. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.ConvertTo``1(System.Object,``0)">
             <summary>   Convert to. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <typeparam name="T">    . </typeparam>
             <param name="value">    . </param>
             <param name="input">    . </param>
            
             <returns>   to converted. </returns>
        </member>
        <member name="F:WD.DataAccess.Helpers.HelperUtility.prefixPattern">
            <summary>
            The prefix pattern
            </summary>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.AddParameters(System.Data.IDbCommand,WD.DataAccess.Parameters.DBParameter[],System.Int32)">
             <summary>   Adds the parameters. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbCommand">    . </param>
             <param name="aParams">      . </param>
             <param name="dbProvider">   . </param>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.ToRecordset(System.Data.DataTable)">
             <summary>   Converts an inTable to a recordset. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="inTable">  . </param>
            
             <returns>   InTable as an ADODB.Recordset. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.TranslateType(System.Type)">
             <summary>   Translate type. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="columnType">   . </param>
            
             <returns>   An ADODB.DataTypeEnum. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.ValueToString(System.Object)">
             <summary>   Value to string. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="value">    . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.GetDbProvider(System.String)">
             <summary>   Gets database provider. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
            
             <returns>   The database provider. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.GetDbProviderName(System.Int32)">
             <summary>   Gets database provider name. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="dbProvider">   . </param>
            
             <returns>   The database provider name. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.Decrypt(System.String)">
             <summary>   Decrypts. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="strInCode">    The in code. </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.MoveToTemporaryDirectory(System.String)">
             <summary>   Move file to temporary directory. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="filePath"> . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.MoveToDirectory(System.String,System.String)">
             <summary>   Move file to directory. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="filePath"> . </param>
             <param name="folder">   . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.CopyToTemporaryDirectory(System.String)">
             <summary>   Copies to temporary directory described by filePath. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="filePath"> . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.HelperUtility.DbDateTime(System.DateTime,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="format"></param>
            <param name="dbProvider"></param>
            <returns></returns>
        </member>
        <member name="T:WD.DataAccess.Helpers.SqlStatement">
             <summary>   (Serializable) a SQL statement. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Helpers.SqlStatement.CommandText">
             <summary>   Open Sql Statement or Procedure Name. </summary>
            
             <value> The command text. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.SqlStatement.CommandType">
             <summary>   CommandType for Text or StoredProcedure (1 or 4) </summary>
            
             <value> The type of the command. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.SqlStatement.Params">
             <summary>   Collection of Parameters. </summary>
            
             <value> The parameters. </value>
        </member>
        <member name="T:WD.DataAccess.Helpers.WebSecurityUtility">
             <summary>   A web security utility. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Helpers.WebSecurityUtility.Decrypt(System.String,System.Boolean)">
             <summary>   Decrypts. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="cipherString"> . </param>
             <param name="useHashing">   . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="M:WD.DataAccess.Helpers.WebSecurityUtility.Encrypt(System.String,System.Boolean)">
             <summary>   Encrypts. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="toEncrypt">    . </param>
             <param name="useHashing">   . </param>
            
             <returns>   A string. </returns>
        </member>
        <member name="P:WD.DataAccess.Helpers.WebSecurityUtility.Key">
             <summary>   Gets the key. </summary>
            
             <value> The key. </value>
        </member>
        <member name="T:WD.DataAccess.Helpers.Wrapper">
             <summary>   Wrapper Class for Web Api. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="P:WD.DataAccess.Helpers.Wrapper.TheSql">
             <summary>
             Collection of SQL Statements with CommandText, CommandType and Collection of Parameters.
             </summary>
            
             <value> the SQL. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.Wrapper.AuthenticationToken">
             <summary>   Authentication Token. </summary>
            
             <value> The authentication token. </value>
        </member>
        <member name="P:WD.DataAccess.Helpers.Wrapper.Connect">
             <summary>   Connection Class for DbContext Initialization. </summary>
            
             <value> The connect. </value>
        </member>
        <member name="T:WD.DataAccess.Logger.ILogger">
             <summary>   A logger. 
             Used to log activities, exceptions, information and errors.
             It uses Log4Net library for logging purpose.
             This class cannot be inherited.  
             </summary>
            
             <remarks>   Shahid Kochak, Asim, 7/21/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Logger.ILogger.iLog">
            <summary>   Zero-based index of the log. </summary>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.#ctor">
             <summary>   Default constructor. 
             Reads the WDlog.config file to get the Logfile name and initialize the log configurations.
             </summary>
            
             <remarks>   Shahid Kochak, Asim, 7/21/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Error(System.Exception)">
             <summary>   Logs an object with the log4net.Core.Level.Error level.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                 //some code
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Error(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
                 This method first checks if this logger is ERROR enabled by comparing the
                 level of this logger with the log4net.Core.Level.Error level. If this logger
                 is ERROR enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Error(object,Exception) form instead.
             Shahid Kochak, Asim, 7/21/2017.
             <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="ERRORLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="ERROR"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinError.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="ERROR" /> //
                    <levelMax value="ERROR" /> //
              </filter>
                </appender>
                <root>
                  <level value="ERROR" /> //
                  <appender-ref ref="ERRORLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>  
                </remarks>
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Error(System.Object)">
             <summary>   Logs a message object with the log4net.Core.Level.Error level.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                 //some code
                   WD.DataAccess.Logger.ILogger.ILog.Error("some text or object");
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Error(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is ERROR enabled by comparing the
                 level of this logger with the log4net.Core.Level.Error level. If this logger
                 is ERROR enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Error(object,Exception) form instead.
             Shahid Kochak, Asim, 7/21/2017. 
             <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="ERRORLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="ERROR"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinError.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="ERROR" /> //
                    <levelMax value="ERROR" /> //
              </filter>
                </appender>
                <root>
                  <level value="ERROR" /> //
                  <appender-ref ref="ERRORLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
             </remarks>
            
             <param name="item"> . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Error(System.Object,System.Exception)">
             <summary>   Log a message object with the log4net.Core.Level.Error level including the
                 stack trace of the System.Exception passed as a parameter.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                 //some code
                   WD.DataAccess.Logger.ILogger.ILog.Error("some text or object");
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Error("some text or object",exc);
             }
             }
             }
             </code>
            </example>
             <remarks>
             <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="ERRORLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="ERROR"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinError.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="ERROR" /> //
                    <levelMax value="ERROR" /> //
              </filter>
                </appender>
                <root>
                  <level value="ERROR" /> //
                  <appender-ref ref="ERRORLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
             </remarks>
             <param name="item"> . </param>
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Info(System.Exception)">
             <summary>   Logs an object with the log4net.Core.Level.Info level.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                 //some code
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Info(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is INFO enabled by comparing the
                 level of this logger with the log4net.Core.Level.Info level. If this logger
                 is INFO enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Info(object,Exception) form instead.
             Shahid Kochak, Asim, 7/21/2017. 
              <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="INFOLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="INFO"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinInfo.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="INFO" /> //
                    <levelMax value="INFO" /> //
              </filter>
                </appender>
                <root>
                  <level value="INFO" /> //
                  <appender-ref ref="INFOLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
             </remarks>
            
             <param name="exc">  . </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:WD.DataAccess.Logger.ILogger.Info(System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:WD.DataAccess.Logger.ILogger.Info(System.Object,System.Exception)" -->
        <member name="M:WD.DataAccess.Logger.ILogger.Debug(System.Exception)">
             <summary>   Debugs the given exc. 
            Log the contents of Exception object as Debug Level.
            </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                //some code
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Debug(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
                            <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="DEBUGLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="DEBUG"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinDebug.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="DEBUG" /> //
                    <levelMax value="DEBUG" /> //
              </filter>
                </appender>
                <root>
                  <level value="INFO" /> //
                  <appender-ref ref="INFOLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
                         </remarks>
            
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Debug(System.Object)">
             <summary>   Debugs the given item. 
             Log the message object as Debug level.
             </summary>
            
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                 WD.DataAccess.Logger.ILogger.ILog.Debug("some message or object");
                
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Debug(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
                            <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="DEBUGLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="DEBUG"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinDebug.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="DEBUG" /> //
                    <levelMax value="DEBUG" /> //
              </filter>
                </appender>
                <root>
                  <level value="INFO" /> //
                  <appender-ref ref="INFOLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
                         </remarks>
            
             <param name="item"> . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Debug(System.Object,System.Exception)">
             <summary>   Debugs. 
             Logs the message object as Debug level, including the stacktrace information from Exception parameter.
             </summary>
            
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                //some code
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Debug("some message or object,exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
                            <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="DEBUGLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="DEBUG"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinDebug.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="DEBUG" /> //
                    <levelMax value="DEBUG" /> //
              </filter>
                </appender>
                <root>
                  <level value="INFO" /> //
                  <appender-ref ref="INFOLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
                         </remarks>
            
             <param name="item"> . </param>
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Fatal(System.Exception)">
             <summary>   Log a message object with the log4net.Core.Level.Fatal level. </summary>
            
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                //some code
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Fatal(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is FATAL enabled by comparing the
                 level of this logger with the log4net.Core.Level.Fatal level. If this logger
                 is FATAL enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Fatal(object,Exception) form instead.  
                            <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="FatalLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="FATAL"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinFatal.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="FATAL" /> //
                    <levelMax value="FATAL" /> //
              </filter>
                </appender>
                <root>
                  <level value="FATAL" /> //
                  <appender-ref ref="FatalLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
                         </remarks>
            
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Fatal(System.Object)">
             <summary>   Log a message object with the log4net.Core.Level.Fatal level. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                WD.DataAccess.Logger.ILogger.ILog.Fatal("some message or object");
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Fatal(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is FATAL enabled by comparing the
                 level of this logger with the log4net.Core.Level.Fatal level. If this logger
                 is FATAL enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Fatal(object,Exception) form instead.
                            <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="FatalLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="FATAL"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinFatal.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="FATAL" /> //
                    <levelMax value="FATAL" /> //
              </filter>
                </appender>
                <root>
                  <level value="FATAL" /> //
                  <appender-ref ref="FatalLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
             
             </remarks>
            
             <param name="item"> . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Fatal(System.Object,System.Exception)">
             <summary>  Log a message object with the log4net.Core.Level.Fatal level including the
                 stack trace of the System.Exception passed as a parameter. 
                 </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
               //some code here
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Fatal("some message or object",exc);
             }
             }
             }
             </code>
            </example>
             <remarks>             
                            <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="FatalLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="FATAL"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinFatal.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="FATAL" /> //
                    <levelMax value="FATAL" /> //
              </filter>
                </appender>
                <root>
                  <level value="FATAL" /> //
                  <appender-ref ref="FatalLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
             </remarks>
             <param name="item"> . </param>
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Warn(System.Exception)">
             <summary>  Log an object with the log4net.Core.Level.Warn level.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
               //some code here
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Fatal(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is WARN enabled by comparing the
                 level of this logger with the log4net.Core.Level.Warn level. If this logger
                 is WARN enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Warn(object,Exception) form instead.
             
                             <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="WarnLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="WARN"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinWarn.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="FATAL" /> //
                    <levelMax value="FATAL" /> //
              </filter>
                </appender>
                <root>
                  <level value="WARN" /> //
                  <appender-ref ref="WarnLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
                   </remarks>
            
             <param name="exc">  . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Warn(System.Object)">
             <summary>   Log a message object with the log4net.Core.Level.Warn level.
             </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
                WD.DataAccess.Logger.ILogger.ILog.Fatal("some message or object");
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Fatal(exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is WARN enabled by comparing the
                 level of this logger with the log4net.Core.Level.Warn level. If this logger
                 is WARN enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                 WARNING Note that passing an System.Exception to this method will print the
                 name of the System.Exception but no stack trace. To print a stack trace use
                 the Warn(object,Exception) form instead.
                                  <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="WarnLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="WARN"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinWarn.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="FATAL" /> //
                    <levelMax value="FATAL" /> //
              </filter>
                </appender>
                <root>
                  <level value="WARN" /> //
                  <appender-ref ref="WarnLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
            </remarks>
            
             <param name="item"> . </param>
        </member>
        <member name="M:WD.DataAccess.Logger.ILogger.Warn(System.Object,System.Exception)">
             <summary>  Log a message object with the log4net.Core.Level.Warn level including the
                 stack trace of the System.Exception passed as a parameter. </summary>
            <example>
             <code>
             class TestClass
             {
             static void Main()
             {
             try{
               //some code here
                   
             }
             catch(Exception exc){
                 WD.DataAccess.Logger.ILogger.ILog.Warn("some message or object",exc);
             }
             }
             }
             </code>
            </example>
             <remarks>   
             This method first checks if this logger is WARN enabled by comparing the
                 level of this logger with the log4net.Core.Level.Warn level. If this logger
                 is WARN enabled, then it converts the message object (passed as parameter)
                 to a string by invoking the appropriate log4net.ObjectRenderer.IObjectRenderer.
                 It then proceeds to call all the registered appenders in this logger and
                 also higher in the hierarchy depending on the value of the additivity flag.
                             <code>
                    <configuration>
              <configSections>
                // Level 1 //
                <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler,log4net"/> //
                // Level 2 //
              </configSections>
              <log4net>
                <appender name="WarnLogFileAppender" type="log4net.Appender.RollingFileAppender">
                  <threshold value="WARN"></threshold>
                  <lockingModel type="log4net.Appender.FileAppender+MinimalLock" /> //
                  <file value="E:\Logs\WinWarn.txt" /> //
                  <appendToFile value="true" /> //
                  <rollingStyle value="date" /> //
                  <datePattern value="yyyyMMdd" /> //
                  <maxSizeRollBackups value="10" /> //
                  <maximumFileSize value="1000KB" /> //
                  <layout type="log4net.Layout.PatternLayout">
                    <conversionPattern value="%date [%thread] %5level %logger %message%newline  %Exception" /> //
                  </layout>
              <filter type="log4net.Filter.LevelRangeFilter">
                    <levelMin value="FATAL" /> //
                    <levelMax value="FATAL" /> //
              </filter>
                </appender>
                <root>
                  <level value="WARN" /> //
                  <appender-ref ref="WarnLogFileAppender" /> //
                </root>
              </log4net>
             </configuration>
                   </code>
             </remarks>  
            
             <param name="item"> . </param>
             <param name="exc">  . </param>
        </member>
        <member name="T:WD.DataAccess.Logger.LogAppender">
             <summary>   A log appender. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Logger.LogAppender.dbProvider">
            <summary>   The database provider. </summary>
        </member>
        <member name="F:WD.DataAccess.Logger.LogAppender.name">
            <summary>
            
            </summary>
        </member>
        <member name="F:WD.DataAccess.Logger.LogAppender.connectionString">
            <summary>   The connection string. </summary>
        </member>
        <member name="M:WD.DataAccess.Logger.LogAppender.Close">
             <summary>   Closes the appender and releases resources. </summary>
            
             <remarks>
             <para>
             Releases any resources allocated within the appender such as file handles, network
             connections, etc.
             </para>
             <para>
             It is a programming error to append to a closed appender.
             </para>
             </remarks>
        </member>
        <member name="M:WD.DataAccess.Logger.LogAppender.DoAppend(log4net.Core.LoggingEvent)">
             <summary>   Log the logging event in Appender specific way. </summary>
            
             <remarks>
             <para>
             This method is called to log a message into this appender.
             </para>
             </remarks>
            
             <param name="loggingEvent"> The event to log. </param>
        </member>
        <member name="M:WD.DataAccess.Logger.LogAppender.DoAppend(log4net.Core.LoggingEvent[])">
             <summary>   Log the array of logging events in Appender specific way. </summary>
            
             <remarks>
             <para>
             This method is called to log an array of events into this appender.
             </para>
             </remarks>
            
             <param name="loggingEvents">    The events to log. </param>
        </member>
        <member name="M:WD.DataAccess.Logger.LogAppender.ActivateOptions">
             <summary>   Activate the options that were previously set with calls to properties. </summary>
            
             <remarks>
             <para>
             This allows an object to defer activation of its options until all options have been set.
             This is required for components which have related options that remain ambiguous until all
             are set.
             </para>
             <para>
             If a component implements this interface then this method must be called after its properties
             have been set before the component can be used.
             </para>
             </remarks>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.RegexStatement">
             <summary>   Gets the RegEx statement. </summary>
            
             <value> The RegEx statement. </value>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.RegexSelectStatement">
             <summary>   Gets the RegEx select statement. </summary>
            
             <value> The RegEx select statement. </value>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.RegexInsertStatement">
             <summary>   Gets the RegEx insert statement. </summary>
            
             <value> The RegEx insert statement. </value>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.RegexUpdateStatement">
             <summary>   Gets the RegEx update statement. </summary>
            
             <value> The RegEx update statement. </value>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.RegexDeleteStatement">
             <summary>   Gets the RegEx delete statement. </summary>
            
             <value> The RegEx delete statement. </value>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.RegexWhereClause">
             <summary>   Gets the RegEx where clause. </summary>
            
             <value> The RegEx where clause. </value>
        </member>
        <member name="E:WD.DataAccess.Logger.LogAppender.DoActiveOptions">
            <summary>   Event queue for all listeners interested in DoActiveOptions events. </summary>
        </member>
        <member name="E:WD.DataAccess.Logger.LogAppender.DoLogging">
            <summary>   Event queue for all listeners interested in DoLogging events. </summary>
        </member>
        <member name="E:WD.DataAccess.Logger.LogAppender.DoLoggings">
            <summary>   Event queue for all listeners interested in DoLoggings events. </summary>
        </member>
        <member name="P:WD.DataAccess.Logger.LogAppender.Name">
             <summary>   Gets or sets the name of this appender. </summary>
            
             <remarks>   <para>The name uniquely identifies the appender.</para> </remarks>
            
             <value> The name of the appender. </value>
        </member>
        <member name="T:WD.DataAccess.Logger.LogAppender.Logging">
             <summary>   Loggings the given loggin event. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="logginEvent">  The loggin event. </param>
        </member>
        <member name="T:WD.DataAccess.Logger.LogAppender.Loggings">
             <summary>   Loggings the given logging events. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="loggingEvents">    The logging events. </param>
        </member>
        <member name="T:WD.DataAccess.Logger.LogAppender.ActiveOptions">
             <summary>   Active options. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="T:WD.DataAccess.Parameters.DBParameter">
             <summary>   A database parameter. </summary>
            
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="F:WD.DataAccess.Parameters.DBParameter.name">
            <summary>   The name. </summary>
        </member>
        <member name="F:WD.DataAccess.Parameters.DBParameter.value">
            <summary>   The value. </summary>
        </member>
        <member name="F:WD.DataAccess.Parameters.DBParameter.paramDirection">
            <summary>   The parameter direction. </summary>
        </member>
        <member name="M:WD.DataAccess.Parameters.DBParameter.#ctor">
             <summary>
             Defaule constructor. Paramete name, vale, type and direction needs to be assigned explicitly
             by using the public properties exposed.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
             DBParameter param=new DBParameter();
               param.ParameterName="F";
               param.ParameterValue="XXX";
             }
             } 
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
        </member>
        <member name="M:WD.DataAccess.Parameters.DBParameter.#ctor(System.String,System.Object)">
             <summary>
             Creates a parameter with the name and value specified. Default data type and direction is
             String and Input respectively.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
             DBParameter param=new DBParameter("FirstName","XXXX");
             }
             } 
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="name">     Parameter name. </param>
             <param name="value">    Value associated with the parameter. </param>
        </member>
        <member name="M:WD.DataAccess.Parameters.DBParameter.#ctor(System.String,System.Object,System.Data.ParameterDirection)">
             <summary>
             Creates a parameter with the name, value and direction specified. Default data type is String.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
             DBParameter param=new DBParameter("FirstName","XXXX",ParameterDirection.Input);
             }
             } 
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="name">             Parameter name. </param>
             <param name="value">            Value associated with the parameter. </param>
             <param name="paramDirection">   Parameter direction. </param>
        </member>
        <member name="M:WD.DataAccess.Parameters.DBParameter.#ctor(System.String,System.Object,System.Data.DbType)">
             <summary>
             Creates a parameter with the name, value and Data type specified. Default direction is Input.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
             DBParameter param=new DBParameter("FirstName","XXXX",DbType.AnsiString);
             }
             } 
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="name">     Parameter name. </param>
             <param name="value">    Value associated with the parameter. </param>
             <param name="dbType">   Data type. </param>
            
             ### <param name="dbProvider">   Data type. </param>
        </member>
        <member name="M:WD.DataAccess.Parameters.DBParameter.#ctor(System.String,System.Object,System.Data.DbType,System.Data.ParameterDirection)">
             <summary>
             Creates a parameter with the name, value, data type and direction specified.
             </summary>
            <example>
             <code>
             class TestClass{
             static void Main(){
             DBParameter param=new DBParameter("FirstName","XXXX",DbType.AnsiString,ParameterDirection.Input);
             }
             } 
             </code>
            </example>
             <remarks>   Shahid Kochak, 7/20/2017. </remarks>
            
             <param name="name">             Parameter name. </param>
             <param name="value">            Value associated with the parameter. </param>
             <param name="dbType">           Data type. </param>
             <param name="paramDirection">   Parameter direction. </param>
        </member>
        <member name="P:WD.DataAccess.Parameters.DBParameter.ParameterName">
             <summary>   Gets or sets the name of the parameter. </summary>
            
             <value> The name of the parameter. </value>
        </member>
        <member name="P:WD.DataAccess.Parameters.DBParameter.ParameterValue">
             <summary>   Gets or sets the value associated with the parameter. </summary>
            
             <value> The parameter value. </value>
        </member>
        <member name="P:WD.DataAccess.Parameters.DBParameter.Type">
             <summary>   Gets or sets the type of the parameter. </summary>
            
             <value> The type. </value>
        </member>
        <member name="P:WD.DataAccess.Parameters.DBParameter.ParamDirection">
             <summary>   Gets or sets the direction of the parameter. </summary>
            
             <value> The parameter direction. </value>
        </member>
    </members>
</doc>
